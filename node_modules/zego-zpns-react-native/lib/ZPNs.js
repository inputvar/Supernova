import { NativeModules, NativeEventEmitter, Platform, AppRegistry } from 'react-native';
const { ZPNsNativeModule } = NativeModules;
const Prefix = ZPNsNativeModule.prefix;
const ZIMEvent = new NativeEventEmitter(ZPNsNativeModule);
export default class ZPNs {
    constructor() {
        this.evs = ['registered', 'notificationArrived', 'notificationClicked', 'throughMessageReceived'];
    }
    /**
     * Gets the SDK's version number.
     *
     * When the SDK is running, the developer finds that it does not match the expected situation and submits the problem and related logs to the ZEGO technical staff for locating. The ZEGO technical staff may need the information of the engine version to assist in locating the problem.
     * Developers can also collect this information as the version information of the engine used by the app, so that the SDK corresponding to each version of the app on the line.
     * @return {string} - SDK version
     */
    static getVersion() {
        return ZPNsNativeModule.getVersion();
    }
    /**
     * Get ZPNs Instance
     */
    static getInstance() {
        return ZPNs._instatance;
    }
    /**
     * Use debug environment. The default value is false.
     */
    static enableDebug(isDebug) {
        return ZPNsNativeModule.enableDebug(isDebug);
    }
    static setPushConfig(config) {
        if (!config.appType)
            config.appType = 0;
        // if (Platform.OS == 'ios' && config.appType < 2) return Promise.resolve();
        return ZPNsNativeModule.setPushConfig(config);
    }
    /**
     * Android Only
     * Register the background service by registerHeadlessTask.
     */
    static setBackgroundMessageHandler(handler) {
        if (Platform.OS == 'android') {
            console.log('ZPNs event service setBackgroundMessageHandler');
            AppRegistry.registerHeadlessTask('ZPNsRNSDKHeadlessJsTaskService', () => (message) => new Promise((resolve) => {
                try {
                    console.log('ZPNs event service start', JSON.stringify(message));
                    if (message.extras) {
                        message.extras = JSON.parse(message.extras);
                        message.content = message.extras.body || message.content;
                        delete message.extras.title;
                        delete message.extras.body;
                    }
                    handler(message);
                    ZPNsNativeModule.writeCustomLog(JSON.stringify(message), 'JSAPI.emit.setBackgroundMessageHandler');
                }
                catch (error) { }
                resolve();
            }));
            ZPNsNativeModule.writeCustomLog('', 'JSAPI.on.setBackgroundMessageHandler');
        }
    }
    /**
     * Register ZPNs Event
     * @param type
     * @param listener
     */
    on(type, listener) {
        if (this.evs.indexOf(type) == -1)
            throw new Error(type + ' is not a supported event type.');
        if (!listener || typeof listener != 'function')
            throw new Error('listener must be a function.');
        this.off(type);
        const native_listener = (res) => {
            try {
                let message = res.message;
                console.log('ZPNs event', type, JSON.stringify(message));
                if (Platform.OS == 'ios') {
                    if (type == 'throughMessageReceived') {
                        const seq = message.seq;
                        delete message.seq;
                        message = { pushSourceType: 1, title: '', content: '', extras: message };
                        listener(message);
                        ZPNsNativeModule.completeThroughMessageReceived(seq);
                    }
                    else {
                        listener(message);
                    }
                }
                else {
                    if (message.extras) {
                        message.extras = JSON.parse(message.extras);
                        message.content = message.extras.body || message.content;
                        delete message.extras.title;
                        delete message.extras.body;
                    }
                    listener(message);
                }
                // ZPNsNativeModule.writeCustomLog(JSON.stringify(message), 'JSAPI.emit.' + type);
            }
            catch (error) {
                console.error(error);
            }
        };
        ZIMEvent.addListener(Prefix + type, native_listener);
        // ZPNsNativeModule.writeCustomLog('', 'JSAPI.on.' + type);
    }
    /**
     * Unregister ZPNs Event
     * @param type
     */
    off(type) {
        if (this.evs.indexOf(type) == -1)
            throw new Error(type + ' is not a supported event type.');
        ZIMEvent.removeAllListeners(Prefix + type);
    }
    /**
     * Apply notification permission. iOS Only
     */
    applyNotificationPermission() {
        if (Platform.OS == 'ios')
            return ZPNsNativeModule.applyNotificationPermission();
        else
            return Promise.resolve();
    }
    /**
     * Register push
     */
    registerPush(config) {
        //config = { enableIOSVoIP: false, iOSNotificationArrivedConfig: {isPresentBadge: false, isPresentSound: false, isPresentAlert: false}, ...config };
        var enableIOSVoIP = false;
        var iOSNotificationArrivedConfig = { isPresentBadge: false, isPresentSound: false, isPresentAlert: false };
        var iOSEnvironment = -1;
        if (config !== undefined) {
            if (config.enableIOSVoIP !== undefined) {
                enableIOSVoIP = config.enableIOSVoIP;
            }
            if (config.iOSEnvironment !== undefined) {
                iOSEnvironment = config.iOSEnvironment;
            }
            if (config.iOSNotificationArrivedConfig !== undefined) {
                iOSNotificationArrivedConfig = config.iOSNotificationArrivedConfig;
            }
        }
        return ZPNsNativeModule.registerPush(enableIOSVoIP, iOSEnvironment, iOSNotificationArrivedConfig);
    }
    unregisterPush() {
        return ZPNsNativeModule.unregisterPush();
    }
    /**
     * Android Only
     */
    createNotificationChannel(channel) {
        if (Platform.OS == 'android')
            ZPNsNativeModule.createNotificationChannel(channel);
    }
    addLocalNotification(message) {
        ZPNsNativeModule.addLocalNotification(message);
    }
}
ZPNs._instatance = new ZPNs();
export { ZPNs };
