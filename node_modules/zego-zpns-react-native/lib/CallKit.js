import { NativeModules, NativeEventEmitter, Platform } from 'react-native';
const { ZPNsNativeModule } = NativeModules;
const Prefix = ZPNsNativeModule.prefix;
const ZIMEvent = new NativeEventEmitter(ZPNsNativeModule);
export class CallKit {
    constructor() {
        this.isIOS = Platform.OS == 'ios' || Platform.OS == 'macos';
        this.evs = [
            'didReceiveIncomingPush',
            'providerDidReset',
            'providerDidBegin',
            'didActivateAudioSession',
            'didDeactivateAudioSession',
            'timedOutPerformingAction',
            'performStartCallAction',
            'performAnswerCallAction',
            'performEndCallAction',
            'performSetHeldCallAction',
            'performSetMutedCallAction',
            'performSetGroupCallAction',
            'performPlayDTMFCallAction',
        ];
    }
    static setInitConfiguration(config) {
        if (Platform.OS == 'ios')
            ZPNsNativeModule.setCallKitInitConfig(config);
    }
    static getInstance() {
        return CallKit._instatance;
    }
    on(type, listener) {
        if (!this.isIOS)
            return;
        if (this.evs.indexOf(type) == -1)
            throw new Error(type + ' is not a supported event type.');
        if (!listener || typeof listener != 'function')
            throw new Error('listener must be a function.');
        this.off(type);
        const native_listener = (res) => {
            try {
                console.log('ZPNs event', type, JSON.stringify(res));
                const { message, seq } = res;
                switch (type) {
                    case 'didReceiveIncomingPush':
                        listener(message, seq);
                        break;
                    case 'timedOutPerformingAction':
                    case 'performStartCallAction':
                    case 'performAnswerCallAction':
                    case 'performEndCallAction':
                    case 'performSetHeldCallAction':
                    case 'performSetMutedCallAction':
                    case 'performSetGroupCallAction':
                    case 'performPlayDTMFCallAction':
                        // @ts-ignore
                        listener({
                            fail: () => ZPNsNativeModule.completeActionFail(seq),
                            fulfill: () => ZPNsNativeModule.completeActionFullFill(seq),
                        });
                        break;
                    default:
                        // @ts-ignore
                        listener();
                        break;
                }
                // ZPNsNativeModule.writeCustomLog(JSON.stringify(res), 'JSAPI.emit.' + type);
            }
            catch (error) {
                console.error(error);
            }
        };
        ZIMEvent.addListener(Prefix + type, native_listener);
        // ZPNsNativeModule.writeCustomLog('', 'JSAPI.on.' + type);
    }
    off(type) {
        if (!this.isIOS)
            return;
        if (this.evs.indexOf(type) == -1)
            throw new Error(type + ' is not a supported event type.');
        ZIMEvent.removeAllListeners(Prefix + type);
    }
    reportIncomingCall(cxCallUpdate, uuid) {
        if (this.isIOS)
            return ZPNsNativeModule.reportIncomingCallWithTitle(cxCallUpdate, uuid);
        else
            return Promise.resolve();
    }
    /// Report that an outgoing call started connecting.
    reportOutgoingCall(uuid) {
        if (this.isIOS)
            return ZPNsNativeModule.reportOutgoingCallWithUUID(uuid);
        else
            return Promise.resolve();
    }
    /// Report an update to call information.
    reportCallUpdate(cxCallUpdate, uuid) {
        if (this.isIOS)
            return ZPNsNativeModule.reportCallUpdateWithUUID(cxCallUpdate, uuid);
        else
            return Promise.resolve();
    }
    /// Report that a call ended. A nil value for `dateEnded` results in the ended date being set to now.
    reportCallEnded(endedReason, uuid) {
        if (this.isIOS)
            return ZPNsNativeModule.reportCallEndedWithUUID(endedReason, uuid);
        else
            return Promise.resolve();
    }
}
CallKit._instatance = new CallKit();
