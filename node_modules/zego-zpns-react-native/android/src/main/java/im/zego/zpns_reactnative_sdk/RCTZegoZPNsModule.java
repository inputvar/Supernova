package im.zego.zpns_reactnative_sdk;

import android.annotation.SuppressLint;
import android.app.Application;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.net.Uri;
import android.os.Build;
import android.util.Log;
import androidx.annotation.RequiresApi;
import com.facebook.react.EagerModuleProvider;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import im.zego.zim.ZIM;
import im.zego.zpns.ZPNsManager;
import im.zego.zpns.callback.ZPNsPushEventHandler;
import im.zego.zpns.enums.ZPNsConstants;
import im.zego.zpns.enums.ZPNsErrorCode;
import im.zego.zpns.util.ZPNsConfig;
import im.zego.zpns_reactnative_sdk.internal.ZPNsConverter;
import im.zego.zpns_reactnative_sdk.internal.ZPNsLogWriter;
import im.zego.zpns_reactnative_sdk.internal.ZPNsPluginEventHandler;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.json.JSONObject;

public class RCTZegoZPNsModule extends ReactContextBaseJavaModule {

    public static final String Prefix = "im.zego.zpns.reactnative.";
    public static ReactApplicationContext reactContext;

    public RCTZegoZPNsModule(ReactApplicationContext ctx) {
        super(ctx);
        reactContext = ctx;
        ZIM.getVersion();
    }

    @Override
    public String getName() {
        return "RCTZPNsNativeModule";
    }

    @Override
    public Map<String, Object> getConstants() {
        final Map<String, Object> constants = new HashMap<>();
        constants.put("prefix", Prefix);
        return constants;
    }

    @ReactMethod
    public void addListener(String eventName) {}

    @ReactMethod
    public void removeListeners(Integer count) {}

    @ReactMethod
    public void writeCustomLog(String customLog, String moduleName) {
        ZPNsLogWriter.writeLog(customLog, moduleName);
    }

    @ReactMethod
    public void getVersion(final Promise promise) {
        promise.resolve(ZPNsManager.getInstance().getVersion());
    }

    @ReactMethod
    public void enableDebug(Boolean isDebug, final Promise promise) {
        ZPNsManager.enableDebug(isDebug);
        promise.resolve(null);
    }

    @ReactMethod
    public void setPushConfig(ReadableMap config, final Promise promise) {
        ZPNsConfig configObj = ZPNsConverter.convertPushConfig(config);
        ZPNsManager.setPushConfig(configObj);
        promise.resolve(null);
    }

    @ReactMethod
    public void registerPush(
        Boolean noUsedParam1,
        Integer noUsedParam2,
        ReadableMap noUsedParam3,
        final Promise promise
    ) {
        ZPNsManager
            .getInstance()
            .setEventHandler(
                new ZPNsPushEventHandler() {
                    @Override
                    public void onError(ZPNsConstants.PushSource source, ZPNsErrorCode error) {
                        super.onError(source, error);
                    }
                }
            );

        ZPNsManager.getInstance().registerPush((Application) reactContext.getApplicationContext());
        promise.resolve(null);
    }

    @ReactMethod
    public void unregisterPush(final Promise promise) {
        ZPNsManager.getInstance().unregisterPush();
        promise.resolve(null);
    }

    @ReactMethod
    public void createNotificationChannel(ReadableMap channelMap) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            Application application = (Application) reactContext.getApplicationContext();
            NotificationManager notificationManager = application.getSystemService(NotificationManager.class);

            String channelID = channelMap.hasKey("channelID") ? channelMap.getString("channelID") : "";
            String channelName = channelMap.hasKey("channelName") ? channelMap.getString("channelName") : "";
            String androidSound = channelMap.hasKey("androidSound") ? channelMap.getString("androidSound") : "";

            Uri sound = Uri.parse("android.resource://" + application.getPackageName() + androidSound);
            NotificationChannel channel = new NotificationChannel(
                channelID,
                channelName,
                NotificationManager.IMPORTANCE_HIGH
            );
            channel.setSound(sound, null);

            notificationManager.createNotificationChannel(channel);
        }
    }

    @ReactMethod
    public void addLocalNotification(ReadableMap messageMap) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            Application application = (Application) reactContext.getApplicationContext();
            NotificationManager notificationManager = application.getSystemService(NotificationManager.class);

            String title = messageMap.hasKey("title") ? messageMap.getString("title") : "";
            String content = messageMap.hasKey("content") ? messageMap.getString("content") : "";
            String payload = messageMap.hasKey("payload") ? messageMap.getString("payload") : "";
            String channelID = messageMap.hasKey("channelID") ? messageMap.getString("channelID") : "";
            String androidSound = messageMap.hasKey("androidSound") ? messageMap.getString("androidSound") : "";

            int icon = application.getResources().getIdentifier("ic_launcher", "mipmap", application.getPackageName());

            Notification.Builder builder = new Notification.Builder(application);
            builder.setContentTitle(title);
            builder.setContentText(content);
            builder.setSmallIcon(icon);
            if (!channelID.equals("") && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                builder.setChannelId(channelID);
            }
            if (!androidSound.equals("")) {
                Uri sound = Uri.parse("android.resource://" + application.getPackageName() + androidSound);
                builder.setSound(sound);
            }
            Intent intent = new Intent();
            if (!payload.equals("")) {
                intent.putExtra("payload", payload);
            }
            // FLAG_ONE_SHOT FLAG_IMMUTABLE
            @SuppressLint("UnspecifiedImmutableFlag")
            PendingIntent pendingIntent = PendingIntent.getActivity(
                application,
                0,
                intent,
                PendingIntent.FLAG_IMMUTABLE
            );
            builder.setContentIntent(pendingIntent);
            builder.setAutoCancel(true);

            Notification notification = builder.build();
            notificationManager.notify(1, notification);
        }
    }
}
