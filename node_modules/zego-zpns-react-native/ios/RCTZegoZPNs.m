
#import "RCTZegoZPNs.h"
#import <React/RCTConvert.h>
#import <ZPNs/ZPNs.h>
#import "CallKit/CallKitManager.h"
#import "RCTZPNsEventManager.h"
#import "ZPNsUtils.h"
#import "internal/NSDictionary+safeInvoke.h"
#import "internal/NSMutableArray+safeInvoke.h"
#import "internal/NSMutableDictionary+safeInvoke.h"
#import "internal/NSObject+safeInvoke.h"

static NSString *PREFIX = @"im.zego.zpns.reactnative.";

#define RN_EVENT(oc_method_name) [NSString stringWithFormat:@"%@%@", PREFIX, oc_method_name]

@interface RCTZPNsNativeModule () <ZPNsNotificationCenterDelegate>

@property(nonatomic, assign) BOOL hasListeners;
@property(nonatomic, assign) BOOL isJSLoaded;
@property(nonatomic, assign) BOOL isNeedCallbackRegistered;

@property bool debug;
@end

@implementation RCTZPNsNativeModule

RCT_EXPORT_MODULE()

- (instancetype)init {
  [ZPNs shared];
  [[ZPNsUtils getInstance] writeCustomLog:[NSString stringWithFormat:@"RCTZegoZPNs Init."]
                               moduleName:@""];
  self = [super init];
  if (self) {
    //[[ZPNs shared] setZPNsNotificationCenterDelegate:self];
    NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];
    [defaultCenter removeObserver:self];
    [defaultCenter addObserver:self
                      selector:@selector(handleNotificationClicked:)
                          name:ZPNS_NOTIFICATION_CLICKED_EVENT
                        object:nil];
    [defaultCenter addObserver:self
                      selector:@selector(handleNotificationArrived:)
                          name:ZPNS_NOTIFICATION_ARRIVED_EVENT
                        object:nil];
    [defaultCenter addObserver:self
                      selector:@selector(handleZPNsRegisterSuccess:)
                          name:ZPNS_REGISTERED_SUCCESS_EVENT
                        object:nil];
    [defaultCenter addObserver:self
                      selector:@selector(handleZPNsRegisterFailed:)
                          name:ZPNS_REGISTERED_FAILED_EVENT
                        object:nil];
    [defaultCenter addObserver:self
                      selector:@selector(handleThroughMessageReceived:)
                          name:ZPNS_THROUGH_MESSAGE_RECEIVED_EVENT
                        object:nil];
  }
  if (![[CallKitManager getInstance] isContainInitConfig]) {
    NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];
    NSDictionary *callKitInitConfigDic = [userDefault objectForKey:@"zegoCallKitInitConfig"];
    if (!(callKitInitConfigDic == nil || callKitInitConfigDic == NULL ||
          [callKitInitConfigDic isEqual:[NSNull null]])) {
      [[CallKitManager getInstance] setInitConfig:callKitInitConfigDic ctx:self];
    }
  }

  if ([CallKitManager getInstance].pkPushRegistry == nil) {
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    [CallKitManager getInstance].pkPushRegistry = [[PKPushRegistry alloc] initWithQueue:mainQueue];
    [[CallKitManager getInstance].pkPushRegistry setDelegate:[CallKitManager getInstance]];
    NSMutableSet *desiredPushTypes = [[NSMutableSet alloc] init];
    [desiredPushTypes addObject:PKPushTypeVoIP];
    [CallKitManager getInstance].pkPushRegistry.desiredPushTypes = desiredPushTypes;
  }
  [[ZPNsUtils getInstance] writeCustomLog:[NSString stringWithFormat:@"RCTZegoZPNs Init complete."]
                               moduleName:@""];
  return self;
}

- (dispatch_queue_t)methodQueue {
  return dispatch_get_main_queue();
}

+ (BOOL)requiresMainQueueSetup {
  return YES;  // only do this if your module initialization relies on calling
               // UIKit!
}

- (NSDictionary *)constantsToExport {
  return @{@"prefix" : PREFIX};
}

- (void)startObserving {
  // Set up any upstream listeners or background tasks as necessary
  [[CallKitManager getInstance] hasListeners:YES];
  self.hasListeners = YES;
}

// Will be called when this module's last listener is removed, or on dealloc.
- (void)stopObserving {
  // Remove upstream listeners, stop unnecessary background tasks
  [[CallKitManager getInstance] hasListeners:NO];
  self.hasListeners = NO;
}

- (NSArray<NSString *> *)supportedEvents {
  return @[
    RN_EVENT(@"registered"), RN_EVENT(@"notificationArrived"), RN_EVENT(@"notificationClicked"),
    RN_EVENT(@"throughMessageReceived"),
    // CallKit
    RN_EVENT(@"didReceiveIncomingPush"), RN_EVENT(@"providerDidReset"),
    RN_EVENT(@"providerDidBegin"), RN_EVENT(@"didActivateAudioSession"),
    RN_EVENT(@"didDeactivateAudioSession"), RN_EVENT(@"timedOutPerformingAction"),
    RN_EVENT(@"performStartCallAction"), RN_EVENT(@"performAnswerCallAction"),
    RN_EVENT(@"performEndCallAction"), RN_EVENT(@"performSetHeldCallAction"),
    RN_EVENT(@"performSetMutedCallAction"), RN_EVENT(@"performSetGroupCallAction"),
    RN_EVENT(@"performPlayDTMFCallAction")
  ];
}

- (void)handleZPNsRegisterSuccess:(NSNotification *)data {
  NSString *pushID = [data object];
  if (self.isNeedCallbackRegistered) {
    [self
        sendEventWithName:RN_EVENT(@"registered")
                     body:@{@"message" : @{@"pushID" : pushID, @"errorCode" : @(0), @"msg" : @""}}];
  }

  // 注册成功后检测是否存在 click 事件
  NSDictionary *notificationMap =
      [[RCTZPNsEventManager sharedInstance] getNotificationMapFromClickedNotification];
  NSDictionary *userInfo = [notificationMap objectForKey:@"userInfo"];
  NSString *title = [notificationMap objectForKey:@"title"];
  NSString *content = [notificationMap objectForKey:@"content"];

  if (userInfo) {
    [self sendNotificationClickedEvent:userInfo title:title content:content];
  }
  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"registered success. pushID: %@", pushID]
          moduleName:@""];
}

- (void)handleZPNsRegisterFailed:(NSNotification *)data {
  NSError *error = [data object];
  [self sendEventWithName:RN_EVENT(@"registered")
                     body:@{
                       @"message" : @{
                         @"pushID" : @"",
                         @"errorCode" : @(error.code),
                         @"msg" : error.localizedDescription ? error.localizedDescription : @""
                       }
                     }];
  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"registered failed. error: %@", error]
          moduleName:@""];
}

- (void)handleNotificationArrived:(NSNotification *)data {
  NSDictionary *notificationMap = [data object];
  NSDictionary *userInfo = [notificationMap objectForKey:@"userInfo"];
  NSString *title = [notificationMap objectForKey:@"title"];
  NSString *content = [notificationMap objectForKey:@"content"];

  NSDictionary *messageMap = [self mZPNsMessageWithUserInfo:userInfo title:title content:content];
  [self sendEventWithName:RN_EVENT(@"notificationArrived") body:@{@"message" : messageMap}];

  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"notificationArrived: %@", title]
          moduleName:@""];
}

- (void)handleNotificationClicked:(NSNotification *)data {
  NSDictionary *notificationMap = [data object];
  NSDictionary *userInfo = [notificationMap objectForKey:@"userInfo"];
  NSString *title = [notificationMap objectForKey:@"title"];
  NSString *content = [notificationMap objectForKey:@"content"];
  [self sendNotificationClickedEvent:userInfo title:title content:content];
}

- (void)handleThroughMessageReceived:(NSNotification *)data {
  if (!self.hasListeners) {
    return;
  }

  NSDictionary *userInfo = [data object];
  [self sendEventWithName:RN_EVENT(@"throughMessageReceived") body:@{@"message" : userInfo}];

  NSString *seq = [userInfo objectForKey:@"seq"];
  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"throughMessageReceived: %@", seq]
          moduleName:@""];
}

- (void)sendNotificationClickedEvent:(NSDictionary *)userInfo
                               title:(NSString *)title
                             content:(NSString *)content {
  if (!self.hasListeners) {
    return;
  }

  NSDictionary *messageMap = [self mZPNsMessageWithUserInfo:userInfo title:title content:content];
  [self sendEventWithName:RN_EVENT(@"notificationClicked") body:@{@"message" : messageMap}];
  [[RCTZPNsEventManager sharedInstance] clearBuffer];

  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"notificationClicked: %@", title]
          moduleName:@""];
}

- (NSDictionary *)mZPNsMessageWithUserInfo:(NSDictionary *)userInfo
                                     title:(NSString *)title
                                   content:(NSString *)content {
  NSMutableDictionary *messageMap = [[NSMutableDictionary alloc] init];

  [messageMap setObject:title forKey:@"title"];
  [messageMap setObject:content forKey:@"content"];
  [messageMap setObject:userInfo forKey:@"extras"];
  [messageMap setObject:@1 forKey:@"pushSourceType"];

  return messageMap;
}

- (void)handleIOSEnvironment:(int)env {
  if (env < 0) {
    return;
  }

  if (env == 0) {
    [[RCTZPNsEventManager sharedInstance] enableDebug:false];
    self.debug = false;
  } else if (env == 1) {
    [[RCTZPNsEventManager sharedInstance] enableDebug:true];
    self.debug = true;
  } else if (env == 2) {
    BOOL isSandBoxApp = [ZPNsUtils isSandboxApp];
    [[RCTZPNsEventManager sharedInstance] enableDebug:isSandBoxApp];
    self.debug = isSandBoxApp;
  }
}

RCT_EXPORT_METHOD(writeCustomLog : (NSString *)customLog moduleName : (NSString *)moduleName) {
  [[ZPNsUtils getInstance] writeCustomLog:customLog moduleName:moduleName];
}

RCT_EXPORT_METHOD(getVersion
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  resolve([ZPNs getVersion]);
}

RCT_EXPORT_METHOD(enableDebug
                  : (BOOL)isDebug resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  [[RCTZPNsEventManager sharedInstance] enableDebug:isDebug];
  self.debug = isDebug;
  resolve(nil);
}

RCT_EXPORT_METHOD(setPushConfig
                  : (NSDictionary *)config resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  ZPNsConfig *conf = [[ZPNsConfig alloc] init];
  conf.appType = [RCTConvert int:config[@"appType"]];
  [[ZPNs shared] setPushConfig:conf];
  resolve(nil);
}

RCT_EXPORT_METHOD(applyNotificationPermission
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  if (@available(iOS 10.0, *)) {
    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
    [center
        requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge |
                                         UNAuthorizationOptionSound)
                      completionHandler:^(BOOL granted, NSError *_Nullable error) {
                        if (granted) {
                          // 点击允许
                          [center getNotificationSettingsWithCompletionHandler:^(
                                      UNNotificationSettings *_Nonnull settings){

                          }];

                        } else {
                        }
                      }];
  } else if ([[UIDevice currentDevice].systemVersion floatValue] > 8.0) {
    // iOS8 - iOS10
    [[UIApplication sharedApplication]
        registerUserNotificationSettings:[UIUserNotificationSettings
                                             settingsForTypes:UIUserNotificationTypeAlert |
                                                              UIUserNotificationTypeSound |
                                                              UIUserNotificationTypeBadge
                                                   categories:nil]];
  } else {
    // Fallback on earlier versions
  }

  resolve(nil);
}

RCT_EXPORT_METHOD(registerPush
                  : (BOOL)enableIOSVoIP iOSEnvironment
                  : (int)iOSEnvironment iosNotificationArrivedConfig
                  : (NSDictionary *)iosNotificationArrivedConfig resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  self.isNeedCallbackRegistered = YES;

  [RCTZPNsEventManager sharedInstance].isWillPresentBadge =
      [RCTConvert BOOL:iosNotificationArrivedConfig[@"isPresentBadge"]];
  [RCTZPNsEventManager sharedInstance].isWillPresentSound =
      [RCTConvert BOOL:iosNotificationArrivedConfig[@"isPresentSound"]];
  [RCTZPNsEventManager sharedInstance].isWillPresentAlert =
      [RCTConvert BOOL:iosNotificationArrivedConfig[@"isPresentAlert"]];

  [self handleIOSEnvironment:iOSEnvironment];

  [[ZPNs shared] registerAPNs];
  if (enableIOSVoIP) {
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    PKPushRegistry *voipRegistry = [[PKPushRegistry alloc] initWithQueue:mainQueue];

    [voipRegistry setDelegate:[CallKitManager getInstance]];
    [CallKitManager isProduct:!self.debug];

    NSMutableSet *desiredPushTypes = [[NSMutableSet alloc] init];
    [desiredPushTypes addObject:PKPushTypeVoIP];
    voipRegistry.desiredPushTypes = desiredPushTypes;
    [[CallKitManager getInstance] enableVoIP];
  }
  [[ZPNsUtils getInstance] writeCustomLog:[NSString stringWithFormat:@"regiser push"]
                               moduleName:@""];
  [[CallKitManager getInstance] clearHoldNomalResultArr];
  resolve(nil);
}

RCT_EXPORT_METHOD(unregisterPush
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  self.isNeedCallbackRegistered = NO;
  [[ZPNs shared] unregisterAPNs];
  resolve(nil);
}

RCT_EXPORT_METHOD(addLocalNotification : (NSDictionary *)messageDic) {
  UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];

  UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
  content.title = [messageDic safeObjectForKey:@"title"];
  content.body = [messageDic safeObjectForKey:@"content"];

  NSMutableDictionary *userInfo = [[NSMutableDictionary alloc] init];
  [userInfo safeSetObject:[messageDic safeObjectForKey:@"payload"] forKey:@"payload"];
  content.userInfo = userInfo;

  NSString *sound = [messageDic safeObjectForKey:@"iOSSound"];
  if (sound != nil && ![sound isEqual:@""]) {
    content.sound = [UNNotificationSound soundNamed:sound];
  }
#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 150000
  if (@available(iOS 15.0, *)) {
    content.interruptionLevel = UNNotificationInterruptionLevelActive;
  }
#endif
  UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:@""
                                                                        content:content
                                                                        trigger:nil];
  [center addNotificationRequest:request
           withCompletionHandler:^(NSError *_Nullable error){
           }];
}

#pragma mark - Event complete

RCT_EXPORT_METHOD(completeThroughMessageReceived : (NSString *)seq) {
  [[RCTZPNsEventManager sharedInstance] throughMessageReceivedCompletion:seq];
}

RCT_EXPORT_METHOD(completeActionFail : (NSString *)seq) {
  [[CallKitManager getInstance] ActionFail:seq];
}

RCT_EXPORT_METHOD(completeActionFullFill : (NSString *)seq) {
  [[CallKitManager getInstance] ActionFullFill:seq];
}

#pragma mark - CallKit

RCT_EXPORT_METHOD(setCallKitInitConfig : (NSDictionary *)configDic) {
  [[CallKitManager getInstance] setInitConfig:configDic ctx:self];
  NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];
  [userDefault setObject:(NSDictionary *)configDic forKey:@"zegoCallKitInitConfig"];
}

RCT_EXPORT_METHOD(reportCallUpdateWithUUID
                  : (NSDictionary *)callDic uuid
                  : (NSString *)uuid resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  [[CallKitManager getInstance] reportCallUpdateWithUUID:callDic
                                                    UUID:uuid
                                                resolver:resolve
                                                rejecter:reject];
}

RCT_EXPORT_METHOD(reportIncomingCallWithTitle
                  : (NSDictionary *)updateDic uuid
                  : (NSString *)uuid resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  [[CallKitManager getInstance] reportIncomingCallWithTitle:updateDic
                                                       UUID:uuid
                                                   resolver:resolve
                                                   rejecter:reject];
}

RCT_EXPORT_METHOD(reportOutgoingCallWithUUID
                  : (NSString *)uuid resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  [[CallKitManager getInstance] reportOutgoingCallWithUUID:uuid resolver:resolve rejecter:reject];
}

RCT_EXPORT_METHOD(reportCallEndedWithUUID
                  : (int)reason uuid
                  : (NSString *)uuid resolver
                  : (RCTPromiseResolveBlock)resolve rejecter
                  : (RCTPromiseRejectBlock)reject) {
  [[CallKitManager getInstance] reportCallEndedWithUUID:uuid
                                                 reason:reason
                                               resolver:resolve
                                               rejecter:reject];
}

@end
