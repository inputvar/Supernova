#import "RCTZPNsEventManager.h"
#import "ZPNsUtils.h"
#import "internal/NSDictionary+safeInvoke.h"
#import "internal/NSMutableArray+safeInvoke.h"
#import "internal/NSMutableDictionary+safeInvoke.h"
#import "internal/NSObject+safeInvoke.h"

@interface RCTZPNsEventManager () <ZPNsNotificationCenterDelegate,
                                   UNUserNotificationCenterDelegate> {
  API_AVAILABLE(ios(10), macosx(10.14))
  __weak id<UNUserNotificationCenterDelegate> _originalNotificationCenterDelegate;
  API_AVAILABLE(ios(10), macosx(10.14))
  struct {
    unsigned int willPresentNotification : 1;
    unsigned int didReceiveNotificationResponse : 1;
    unsigned int openSettingsForNotification : 1;
  } _originalNotificationCenterDelegateRespondsTo;
}

@property(nonatomic, assign) BOOL isDebug;

@property(nonatomic, strong) NSDictionary *clickedNotificationMap;  // 改为 notificationMap

@end

static unsigned int _seq = 0;
static NSMutableDictionary *_completionSeqMap = nil;

@implementation RCTZPNsEventManager

+ (void)load {
  [[RCTZPNsEventManager sharedInstance] listenAppDidFinishLaunchingNotification];
}

+ (instancetype)sharedInstance {
  static RCTZPNsEventManager *instance = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    instance = [[self alloc] init];
    _completionSeqMap = [[NSMutableDictionary alloc] init];
  });
  return instance;
}

- (NSString *)generateSeqStr {
  ++_seq;
  NSString *seqStr = [NSString stringWithFormat:@"%u", _seq];
  return seqStr;
}

- (void)listenAppDidFinishLaunchingNotification {
  static dispatch_once_t onceToken;
  __weak RCTZPNsEventManager *weakSelf = self;
  dispatch_once(&onceToken, ^{
    RCTZPNsEventManager *strongSelf = weakSelf;
    // Application
    // Dart -> `getInitialNotification`
    // ObjC -> Initialize other delegates & observers
    [[NSNotificationCenter defaultCenter]
        addObserver:strongSelf
           selector:@selector(application_onDidFinishLaunchingNotification:)
#if TARGET_OS_OSX
               name:NSApplicationDidFinishLaunchingNotification
#else
         name:UIApplicationDidFinishLaunchingNotification
#endif
             object:nil];
  });
}

- (void)registerDeviceToken:(NSData *)deviceToken {
  NSString *dataStr = [self getHexStringForData:deviceToken];
  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:@"isProduct: %d, device token: %@", !self.isDebug,
                                                dataStr]
          moduleName:@""];
  [[ZPNs shared] setDeviceToken:deviceToken isProduct:!self.isDebug];
}

- (void)registerZPNsEventDelegate {
  [[ZPNs shared] setZPNsNotificationCenterDelegate:self];
}

- (void)handleNotificationClickEvent:(NSDictionary *)userInfo
                               title:(NSString *)title
                             content:(NSString *)content {
  // self.clickedUserInfo = userInfo;
  NSMutableDictionary *notificationMap = [NSMutableDictionary dictionary];
  [notificationMap safeSetObject:userInfo forKey:@"userInfo"];
  [notificationMap safeSetObject:title forKey:@"title"];
  [notificationMap safeSetObject:content forKey:@"content"];
  self.clickedNotificationMap = notificationMap;
  [[NSNotificationCenter defaultCenter] postNotificationName:ZPNS_NOTIFICATION_CLICKED_EVENT
                                                      object:notificationMap];
}

- (void)handleNotificationArriveEvent:(NSDictionary *)userInfo
                                title:(NSString *)title
                              content:(NSString *)content {
  NSMutableDictionary *notificationMap = [NSMutableDictionary dictionary];
  [notificationMap safeSetObject:userInfo forKey:@"userInfo"];
  [notificationMap safeSetObject:title forKey:@"title"];
  [notificationMap safeSetObject:content forKey:@"content"];
  [[NSNotificationCenter defaultCenter] postNotificationName:ZPNS_NOTIFICATION_ARRIVED_EVENT
                                                      object:notificationMap];
}

- (void)handleThroughMessageReceivedEvent:(NSDictionary *)userInfo
                   fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  NSString *seq = [self generateSeqStr];
  NSMutableDictionary *mutableDic = [[NSMutableDictionary alloc] initWithDictionary:userInfo];
  [mutableDic setValue:seq forKey:@"seq"];
  [_completionSeqMap safeSetObject:completionHandler forKey:seq];
  [[NSNotificationCenter defaultCenter] postNotificationName:ZPNS_THROUGH_MESSAGE_RECEIVED_EVENT
                                                      object:mutableDic];
}

- (void)handleZPNsRegisterSuccessEvent:(NSString *)pushID {
  [[NSNotificationCenter defaultCenter] postNotificationName:ZPNS_REGISTERED_SUCCESS_EVENT
                                                      object:pushID];
}

- (void)handleZPNsRegisterFailEvent:(NSError *)error {
  [[NSNotificationCenter defaultCenter] postNotificationName:ZPNS_REGISTERED_FAILED_EVENT
                                                      object:error];
}

- (nullable NSDictionary *)getNotificationMapFromClickedNotification {
  // return self.clickedUserInfo;
  return self.clickedNotificationMap;
}

- (void)enableDebug:(BOOL)isDebug {
  self.isDebug = isDebug;
}

- (void)clearBuffer {
  // self.clickedUserInfo = nil;
  self.clickedNotificationMap = nil;
}

- (void)throughMessageReceivedCompletion:(NSString *)seq {
  id completion = [_completionSeqMap safeObjectForKey:seq];
  ((void (^)(UIBackgroundFetchResult))completion)(0);
}

- (NSString *)getHexStringForData:(NSData *)data {
  if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 13) {
    if (![data isKindOfClass:[NSData class]]) {
      return @"";
    }
    NSUInteger len = [data length];
    char *chars = (char *)[data bytes];
    NSMutableString *hexString = [[NSMutableString alloc] init];
    for (NSUInteger i = 0; i < len; i++) {
      [hexString appendString:[NSString stringWithFormat:@"%0.2hhx", chars[i]]];
    }
    return hexString;
  } else {
    NSString *myToken = [[data description]
        stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@"<>"]];
    myToken = [myToken stringByReplacingOccurrencesOfString:@" " withString:@""];
    return myToken;
  }
}

- (NSString *)getUserInfoJson:(NSDictionary *)userInfo {
  if (!userInfo) {
    return @"null";
  }

  NSError *error;
  NSData *jsonData = [NSJSONSerialization dataWithJSONObject:userInfo
                                                     options:NSJSONWritingPrettyPrinted
                                                       error:&error];

  if (!jsonData) {
    return @"null";
  }

  NSString *jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
  return jsonString;
}

#pragma mark - Observe App

- (void)application_onDidFinishLaunchingNotification:(nonnull NSNotification *)notification {
  NSDictionary *remoteNotification =
      notification.userInfo[UIApplicationLaunchOptionsRemoteNotificationKey];
  if (remoteNotification != nil) {
    NSString *jsonData = [self getUserInfoJson:remoteNotification];
    [[ZPNsUtils getInstance]
        writeCustomLog:[NSString stringWithFormat:@"get init notification: %@", jsonData]
            moduleName:@""];
  }

  if (@available(iOS 10.0, macOS 10.14, *)) {
    UNUserNotificationCenter *notificationCenter =
        [UNUserNotificationCenter currentNotificationCenter];

    if (notificationCenter.delegate != nil) {
      _originalNotificationCenterDelegate = notificationCenter.delegate;
      _originalNotificationCenterDelegateRespondsTo.openSettingsForNotification =
          (unsigned int)[_originalNotificationCenterDelegate
              respondsToSelector:@selector(userNotificationCenter:openSettingsForNotification:)];
      _originalNotificationCenterDelegateRespondsTo.willPresentNotification =
          (unsigned int)[_originalNotificationCenterDelegate
              respondsToSelector:@selector(userNotificationCenter:
                                          willPresentNotification:withCompletionHandler:)];
      _originalNotificationCenterDelegateRespondsTo.didReceiveNotificationResponse =
          (unsigned int)[_originalNotificationCenterDelegate
              respondsToSelector:@selector(userNotificationCenter:
                                     didReceiveNotificationResponse:withCompletionHandler:)];

      [[ZPNsUtils getInstance]
          writeCustomLog:
              [NSString
                  stringWithFormat:
                      @"we should save the original delegate to call them. will present: %u, did "
                      @"response: %u, open settings: %u",
                      _originalNotificationCenterDelegateRespondsTo.willPresentNotification,
                      _originalNotificationCenterDelegateRespondsTo.didReceiveNotificationResponse,
                      _originalNotificationCenterDelegateRespondsTo.openSettingsForNotification]
              moduleName:@""];
    }

    __strong RCTZPNsEventManager<UNUserNotificationCenterDelegate> *strongSelf = self;
    notificationCenter.delegate = strongSelf;
  }
}

#pragma mark UNUserNotificationCenterDelegate
- (void)userNotificationCenter:(UNUserNotificationCenter *)center
       willPresentNotification:(UNNotification *)notification
         withCompletionHandler:
             (void (^)(UNNotificationPresentationOptions options))completionHandler
    API_AVAILABLE(macos(10.14), ios(10.0)) {
  [self ZPNsNotificationCenter:center
       willPresentNotification:notification
                      userInfo:notification.request.content.userInfo
         withCompletionHandler:completionHandler];

  // Forward on to any other delegates amd allow them to control presentation behavior.
  if (_originalNotificationCenterDelegate != nil &&
      _originalNotificationCenterDelegateRespondsTo.willPresentNotification) {
    [_originalNotificationCenterDelegate userNotificationCenter:center
                                        willPresentNotification:notification
                                          withCompletionHandler:completionHandler];
  } else {
    UNNotificationPresentationOptions presentationOptions = UNNotificationPresentationOptionNone;
    if (self.isWillPresentBadge) {
      presentationOptions |= UNNotificationPresentationOptionBadge;
    }

    if (self.isWillPresentSound) {
      presentationOptions |= UNNotificationPresentationOptionSound;
    }

    if (self.isWillPresentAlert) {
      presentationOptions |= UNNotificationPresentationOptionAlert;
    }

    completionHandler(presentationOptions);
  }

  [[ZPNsUtils getInstance]
      writeCustomLog:[NSString stringWithFormat:
                                   @"onUserNotificationCenterWillPresentNotification. userInfo: %@",
                                   [self getUserInfoJson:notification.request.content.userInfo]]
          moduleName:@""];
}

// Called when a user interacts with a notification.
- (void)userNotificationCenter:(UNUserNotificationCenter *)center
    didReceiveNotificationResponse:(UNNotificationResponse *)response
             withCompletionHandler:(void (^)(void))completionHandler
    API_AVAILABLE(macos(10.14), ios(10.0)) {
  [self ZPNsNotificationCenter:center
      didReceiveNotificationResponse:response
                            userInfo:response.notification.request.content.userInfo
               withCompletionHandler:completionHandler];

  // Forward on to any other delegates.
  if (_originalNotificationCenterDelegate != nil &&
      _originalNotificationCenterDelegateRespondsTo.didReceiveNotificationResponse) {
    [_originalNotificationCenterDelegate userNotificationCenter:center
                                 didReceiveNotificationResponse:response
                                          withCompletionHandler:completionHandler];
  } else {
    completionHandler();
  }

  [[ZPNsUtils getInstance]
      writeCustomLog:
          [NSString stringWithFormat:
                        @"onUserNotificationCenterDidReceiveNotificationResponse. userInfo: %@",
                        [self getUserInfoJson:response.notification.request.content.userInfo]]
          moduleName:@""];
}

// We don't use this for ZPNs, but for the purpose of forwarding to any original delegates we
// implement this.
- (void)userNotificationCenter:(UNUserNotificationCenter *)center
    openSettingsForNotification:(nullable UNNotification *)notification
    API_AVAILABLE(macos(10.14), ios(10.0)) {
  // Forward on to any other delegates.
  if (_originalNotificationCenterDelegate != nil &&
      _originalNotificationCenterDelegateRespondsTo.openSettingsForNotification) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"
    [_originalNotificationCenterDelegate userNotificationCenter:center
                                    openSettingsForNotification:notification];
#pragma clang diagnostic pop
  }
}

#pragma mark ZPNsNotificationCenterDelegate

- (void)onRegistered:(NSString *)pushID {
  [self handleZPNsRegisterSuccessEvent:pushID];
}

- (void)ZPNsNotificationCenter:(UNUserNotificationCenter *)center
       willPresentNotification:(UNNotification *)notification
                      userInfo:(NSDictionary *)userInfo
         withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler {
  [self handleNotificationArriveEvent:userInfo
                                title:notification.request.content.title
                              content:notification.request.content.body];
}

- (void)ZPNsNotificationCenter:(UNUserNotificationCenter *)center
    didReceiveNotificationResponse:(UNNotificationResponse *)response
                          userInfo:(NSDictionary *)userInfo
             withCompletionHandler:(void (^)(void))completionHandler
    API_AVAILABLE(macos(10.14), ios(10.0)) {
  [self handleNotificationClickEvent:userInfo
                               title:response.notification.request.content.title
                             content:response.notification.request.content.body];
}

@end
