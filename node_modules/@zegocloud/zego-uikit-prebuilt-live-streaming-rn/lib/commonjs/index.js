"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AUDIENCE_DEFAULT_CONFIG", {
  enumerable: true,
  get: function () {
    return _defines.AUDIENCE_DEFAULT_CONFIG;
  }
});
Object.defineProperty(exports, "HOST_DEFAULT_CONFIG", {
  enumerable: true,
  get: function () {
    return _defines.HOST_DEFAULT_CONFIG;
  }
});
Object.defineProperty(exports, "ZegoMenuBarButtonName", {
  enumerable: true,
  get: function () {
    return _ZegoMenuBarButtonName.default;
  }
});
Object.defineProperty(exports, "ZegoUIKitPrebuiltLiveStreamingFloatingMinimizedView", {
  enumerable: true,
  get: function () {
    return _ZegoUIKitPrebuiltLiveStreamingFloatingMinimizedView.default;
  }
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _zegoUikitRn = _interopRequireWildcard(require("@zegocloud/zego-uikit-rn"));
var _ZegoBottomBar = _interopRequireDefault(require("./components/ZegoBottomBar"));
var _keyboard = require("./utils/keyboard");
var _logger = require("./utils/logger");
var _ZegoMenuBarButtonName = _interopRequireDefault(require("./components/ZegoMenuBarButtonName"));
var _ZegoStartLiveButton = _interopRequireDefault(require("./components/ZegoStartLiveButton"));
var _ZegoLiveStreamingMemberList = _interopRequireDefault(require("./components/ZegoLiveStreamingMemberList"));
var _ZegoCoHostMenuDialog = _interopRequireDefault(require("./components/ZegoCoHostMenuDialog"));
var _ZegoToast = _interopRequireDefault(require("./components/ZegoToast"));
var _ZegoDialog = _interopRequireDefault(require("./components/ZegoDialog"));
var _plugins = _interopRequireDefault(require("./services/plugins"));
var _utils = require("./utils");
var _ZegoAudioVideoForegroundView = _interopRequireDefault(require("./components/ZegoAudioVideoForegroundView"));
var _defines = require("./services/defines");
var _ZegoTopBar = _interopRequireDefault(require("./components/ZegoTopBar"));
var _minimizing_helper = _interopRequireDefault(require("./services/minimizing_helper"));
var _prebuilt_helper = _interopRequireDefault(require("./services/prebuilt_helper"));
var _ZegoUIKitPrebuiltLiveStreamingFloatingMinimizedView = _interopRequireDefault(require("./components/ZegoUIKitPrebuiltLiveStreamingFloatingMinimizedView"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// https://github.com/react-native-community/hooks#usekeyboard
function ZegoUIKitPrebuiltLiveStreaming(props, ref) {
  let {
    appID,
    appSign,
    userID,
    userName,
    liveID,
    config,
    plugins = []
  } = props;
  const isMinimizeSwitch = _minimizing_helper.default.getInstance().getIsMinimizeSwitch();
  if (isMinimizeSwitch) {
    // const initAppInfo = MinimizingHelper.getInstance().getInitAppInfo();
    // const initUser = MinimizingHelper.getInstance().getInitUser();
    // const initLiveID = MinimizingHelper.getInstance().getInitRoomID();
    // const initConfig = MinimizingHelper.getInstance().getInitConfig();
    // const initPlugins = MinimizingHelper.getInstance().getInitPlugins();
    // appID = initAppInfo.appID;
    // appSign = initAppInfo.appSign
    // userID = initUser.userID;
    // userName = initUser.userName;
    // liveID = initLiveID;
    // config = initConfig;
    // plugins = initPlugins;
  } else {
    _minimizing_helper.default.getInstance().notifyEntryNormal();
    config.role === undefined && (config.role = _defines.ZegoLiveStreamingRole.audience);
    Object.assign(_defines.ZegoTranslationText, config.translationText || {});
    config.deviceConfirmDialogInfo === undefined && (config.deviceConfirmDialogInfo = {});
    _minimizing_helper.default.getInstance().setInitParams(appID, appSign, userID, userName, liveID, config);
  }
  const showDefaultDeviceOnDialog = (isCamera, formUser) => {
    console.log('########showDefaultDeviceOnDialog', formUser, isCamera);
    return new Promise((resolve, reject) => {
      const {
        title = `${formUser.userID} wants to turn on your ${isCamera ? 'camera' : 'microphone'}`,
        message = `Are you sure to turn on your ${isCamera ? 'camera' : 'microphone'}?`,
        cancelButtonName = "Cancel",
        confirmButtonName = "Confirm"
      } = config.deviceConfirmDialogInfo;
      _reactNative.Alert.alert(title, message, [{
        text: cancelButtonName,
        onPress: () => reject(),
        style: "cancel"
      }, {
        text: confirmButtonName,
        onPress: () => resolve()
      }]);
    });
  };
  const {
    // turnOnCameraWhenJoining = true,
    // turnOnMicrophoneWhenJoining = true,
    // useSpeakerWhenJoining = true,
    audioVideoViewConfig = {},
    bottomMenuBarConfig = {},
    topMenuBarConfig = {},
    memberListConfig = {},
    inRoomMessageViewConfig = {},
    confirmDialogInfo = {},
    onLeaveLiveStreaming,
    onLeaveLiveStreamingConfirming,
    onLiveStreamingEnded,
    onStartLiveButtonPressed,
    startLiveButtonBuilder,
    markAsLargeRoom = false,
    // @ts-ignore
    onCameraTurnOnByOthersConfirmation = showDefaultDeviceOnDialog.bind(this, true),
    // @ts-ignore
    onMicrophoneTurnOnByOthersConfirmation = showDefaultDeviceOnDialog.bind(this, false),
    durationConfig = {}
  } = config;
  const {
    showSoundWavesInAudioMode = true,
    useVideoViewAspectFill = true,
    foregroundBuilder
  } = audioVideoViewConfig;
  const {
    showMicrophoneState = true,
    showCameraState = true,
    itemBuilder
  } = memberListConfig;
  const {
    itemBuilder: messageItemBuilder
  } = inRoomMessageViewConfig;
  const {
    showInRoomMessageButton = true,
    hostButtons = [_ZegoMenuBarButtonName.default.toggleCameraButton, _ZegoMenuBarButtonName.default.toggleMicrophoneButton, _ZegoMenuBarButtonName.default.switchCameraButton],
    coHostButtons = [_ZegoMenuBarButtonName.default.toggleCameraButton, _ZegoMenuBarButtonName.default.toggleMicrophoneButton, _ZegoMenuBarButtonName.default.switchCameraButton, _ZegoMenuBarButtonName.default.coHostControlButton],
    audienceButtons = plugins && plugins.length && plugins.find(plugin => plugin.ZIMConnectionState) ? [_ZegoMenuBarButtonName.default.coHostControlButton] : [],
    hostExtendButtons = [],
    coHostExtendButtons = [],
    audienceExtendButtons = [],
    maxCount = 5
  } = bottomMenuBarConfig;
  const {
    buttons = [_ZegoMenuBarButtonName.default.leaveButton]
  } = topMenuBarConfig;
  const {
    isVisible = true,
    onDurationUpdate
  } = durationConfig;
  const stateData = (0, _react.useRef)(_prebuilt_helper.default.getInstance().getStateData());
  const [turnOnCameraWhenJoining, setTurnOnCameraWhenJoining] = (0, _react.useState)(stateData.current.turnOnCameraWhenJoining !== undefined ? stateData.current.turnOnCameraWhenJoining : config.turnOnCameraWhenJoining);
  const [turnOnMicrophoneWhenJoining, setTurnOnMicrophoneWhenJoining] = (0, _react.useState)(stateData.current.turnOnMicrophoneWhenJoining !== undefined ? stateData.current.turnOnMicrophoneWhenJoining : config.turnOnMicrophoneWhenJoining);
  const [useSpeakerWhenJoining, setUseSpeakerWhenJoining] = (0, _react.useState)(stateData.current.useSpeakerWhenJoining !== undefined ? stateData.current.useSpeakerWhenJoining : config.useSpeakerWhenJoining);
  const keyboardHeight = (0, _keyboard.useKeyboard)();
  const [textInputVisable, setTextInputVisable] = (0, _react.useState)(false);
  const [textInput, setTextInput] = (0, _react.useState)(null);
  const [textInputHeight, setTextInputHeight] = (0, _react.useState)(45);
  const [role, setRole] = (0, _react.useState)(stateData.current.role !== undefined ? stateData.current.role : config.role);
  const [hostID, setHostID] = (0, _react.useState)(stateData.current.hostID || '');
  const [liveStatus, setLiveStatus] = (0, _react.useState)(stateData.current.liveStatus !== undefined ? stateData.current.liveStatus : ''); // init: '' default: 0, start: 1
  const [memberCount, setMemberCount] = (0, _react.useState)(stateData.current.memberCount || 1);
  const [isMemberListVisable, setIsMemberListVisable] = (0, _react.useState)(stateData.current.isMemberListVisable || false);
  const [isPluginsInit, setIsPluginsInit] = (0, _react.useState)(false);
  const [requestCoHostCount, setRequestCoHostCount] = (0, _react.useState)(stateData.current.requestCoHostCount || 0);
  const [memberConnectStateMap, setMemberConnectStateMap] = (0, _react.useState)(stateData.current.memberConnectStateMap || {}); // The connection status of the current member
  const [isCoHostDialogVisable, setIsCoHostDialogVisable] = (0, _react.useState)(false);
  const [coHostDialogExtendedData, setCoHostDialogExtendedData] = (0, _react.useState)({});
  const [isToastVisable, setIsToastVisable] = (0, _react.useState)(false);
  const [toastExtendedData, setToastExtendedData] = (0, _react.useState)({});
  _prebuilt_helper.default.getInstance().notifyZegoDialogTrigger(stateData.current.isDialogVisable || false);
  const [dialogExtendedData, setDialogExtendedData] = (0, _react.useState)(stateData.current.dialogExtendedData || {});
  const [duration, setDuration] = (0, _react.useState)(stateData.current.duration || 0);
  if (stateData.current.callbackID) {
    stateData.current.callbackID = 'ZegoUIKitPrebuiltLiveStreaming' + String(Math.floor(Math.random() * 10000));
  }
  const callbackID = stateData.current.callbackID;
  const hideCountdownOnToastLimit = 5;
  const hideCountdownOnDialogLimit = 60;
  let hideCountdownOnToast = hideCountdownOnToastLimit;
  const hideCountdownOn_Dialog = (0, _react.useRef)(hideCountdownOnDialogLimit);
  const hideCountdownOn_DialogTimer = (0, _react.useRef)(null);
  const liveStreamingTiming = (0, _react.useRef)(stateData.current.duration || 0);
  const liveStreamingTimingTimer = (0, _react.useRef)(stateData.current.liveStreamingTimingTimer || null);
  const realTimeData = (0, _react.useRef)(_prebuilt_helper.default.getInstance().getRealTimeData()); // Resolve the problem where closures cannot obtain new values, add as needed
  if (!isMinimizeSwitch) {
    realTimeData.current.role = config.role;
  }
  const isIgnore = (0, _react.useRef)(false); // Resolved callback delay in receiving room attached message
  const shouldSortHostAtFirst = (0, _react.useRef)(true);
  const debounce = (0, _react.useRef)(false);
  const isPageInBackground = () => {
    const isMinimize = _minimizing_helper.default.getInstance().getIsMinimize();
    console.log('######isPageInBackground', isMinimize);
    return isMinimize;
  };
  const registerPluginCallback = () => {
    if (_zegoUikitRn.default.getPlugin(_zegoUikitRn.ZegoUIKitPluginType.signaling)) {
      _zegoUikitRn.default.getSignalingPlugin().onInvitationReceived(callbackID, _ref => {
        let {
          callID,
          type,
          inviter,
          data
        } = _ref;
        console.log('[Prebuilt]onInvitationReceived', JSON.stringify(realTimeData.current), requestCoHostCount);
        if (type === _defines.ZegoInvitationType.requestCoHost && userID === realTimeData.current.hostID) {
          // The audience created a cohost request
          realTimeData.current.requestCoHostCount += 1;
          stateData.current.requestCoHostCount = realTimeData.current.requestCoHostCount;
          setRequestCoHostCount(realTimeData.current.requestCoHostCount);
          setIsToastVisable(true);
          setToastExtendedData({
            type: _defines.ZegoToastType.success,
            text: _defines.ZegoTranslationText.receivedRequestCoHostToast.replace('%0', inviter.id)
          });
          realTimeData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.connecting;
          stateData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.connecting;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
          setTimeout(() => {
            // The sorting will not be triggered if the member list pop-up is not reopened, the sorting must be forced
            _zegoUikitRn.default.forceSortMemberList();
          }, 50);
        } else if (type === _defines.ZegoInvitationType.inviteToCoHost) {
          // The audience is invited to connect the cohost by host
          const temp = {
            title: _defines.ZegoTranslationText.receivedCoHostInvitationDialogInfo.title,
            content: _defines.ZegoTranslationText.receivedCoHostInvitationDialogInfo.message,
            cancelText: _defines.ZegoTranslationText.receivedCoHostInvitationDialogInfo.cancelButtonName,
            okText: _defines.ZegoTranslationText.receivedCoHostInvitationDialogInfo.confirmButtonName,
            onCancel: () => {
              // Refuse the cohost request of the host
              _zegoUikitRn.default.getSignalingPlugin().refuseInvitation(inviter.id).then(() => {
                realTimeData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
                stateData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
                setMemberConnectStateMap({
                  ...realTimeData.current.memberConnectStateMap
                });
                _zegoUikitRn.default.turnCameraOn('', false);
                _zegoUikitRn.default.turnMicrophoneOn('', false);
                setIsDialogVisableHandle(false);
              });
            },
            onOk: () => {
              // Accept the cohost request of the host
              _zegoUikitRn.default.getSignalingPlugin().acceptInvitation(inviter.id).then(async () => {
                realTimeData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.connected;
                stateData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.connected;
                setMemberConnectStateMap({
                  ...realTimeData.current.memberConnectStateMap
                });
                try {
                  await (0, _utils.grantPermissions)();
                } catch (error) {}
                _zegoUikitRn.default.turnCameraOn('', true);
                _zegoUikitRn.default.turnMicrophoneOn('', true);
                setIsDialogVisableHandle(false);
                setRole(_defines.ZegoLiveStreamingRole.coHost);
                realTimeData.current.role = _defines.ZegoLiveStreamingRole.coHost;
                stateData.current.role = _defines.ZegoLiveStreamingRole.coHost;
              });
            }
          };
          setIsDialogVisableHandle(true);
          setDialogExtendedData(temp);
          stateData.current.dialogExtendedData = temp;
        } else if (type == _defines.ZegoInvitationType.removeCoHost) {
          // The audience was forced off the cohost by host
          _zegoUikitRn.default.turnCameraOn('', false);
          _zegoUikitRn.default.turnMicrophoneOn('', false);
          realTimeData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
          stateData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
          setRole(_defines.ZegoLiveStreamingRole.audience);
          realTimeData.current.role = _defines.ZegoLiveStreamingRole.audience;
          stateData.current.role = _defines.ZegoLiveStreamingRole.audience;
        }
      });
      _zegoUikitRn.default.getSignalingPlugin().onInvitationCanceled(callbackID, _ref2 => {
        let {
          inviter
        } = _ref2;
        if (userID === realTimeData.current.hostID) {
          // The audience canceled the cohost request
          realTimeData.current.requestCoHostCount -= 1;
          stateData.current.requestCoHostCount = realTimeData.current.requestCoHostCount;
          setRequestCoHostCount(realTimeData.current.requestCoHostCount);
          realTimeData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.idle;
          stateData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.idle;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
        }
      });
      _zegoUikitRn.default.getSignalingPlugin().onInvitationTimeout(callbackID, _ref3 => {
        let {
          inviter
        } = _ref3;
        if (userID === realTimeData.current.hostID) {
          // The host did not process the cohost request, resulting in a timeout
          realTimeData.current.requestCoHostCount -= 1;
          stateData.current.requestCoHostCount = realTimeData.current.requestCoHostCount;
          setRequestCoHostCount(realTimeData.current.requestCoHostCount);
          realTimeData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.idle;
          stateData.current.memberConnectStateMap[inviter.id] = _defines.ZegoCoHostConnectState.idle;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
        }
      });
      _zegoUikitRn.default.getSignalingPlugin().onInvitationAccepted(callbackID, _ref4 => {
        let {
          invitee
        } = _ref4;
        if (userID === realTimeData.current.hostID) {
          // The audience accept the cohost request
          realTimeData.current.memberConnectStateMap[invitee.id] = _defines.ZegoCoHostConnectState.connected;
          stateData.current.memberConnectStateMap[invitee.id] = _defines.ZegoCoHostConnectState.connected;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });

          // Reset invitation timer
          setCoHostDialogExtendedData({
            resetTimer: true,
            inviteeID: invitee.id
          });
        }
      });
      _zegoUikitRn.default.getSignalingPlugin().onInvitationRefused(callbackID, _ref5 => {
        let {
          invitee
        } = _ref5;
        if (userID === realTimeData.current.hostID) {
          // The audience reject the cohost request
          realTimeData.current.memberConnectStateMap[invitee.id] = _defines.ZegoCoHostConnectState.idle;
          stateData.current.memberConnectStateMap[invitee.id] = _defines.ZegoCoHostConnectState.idle;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
          setIsToastVisable(true);
          setToastExtendedData({
            type: _defines.ZegoToastType.error,
            text: _defines.ZegoTranslationText.audienceRejectInvitationToast.replace('%0', invitee.id)
          });

          // Reset invitation timer
          setCoHostDialogExtendedData({
            resetTimer: true,
            inviteeID: invitee.id
          });
        }
      });
      _zegoUikitRn.default.getSignalingPlugin().onInRoomTextMessageReceived(callbackID, messageList => {
        console.warn('[Prebuilt]onInRoomTextMessageReceived', messageList);
      });
    }
  };
  const unRegisterPluginCallback = () => {
    if (_zegoUikitRn.default.getPlugin(_zegoUikitRn.ZegoUIKitPluginType.signaling)) {
      _zegoUikitRn.default.getSignalingPlugin().onInvitationReceived(callbackID);
      _zegoUikitRn.default.getSignalingPlugin().onInvitationCanceled(callbackID);
      _zegoUikitRn.default.getSignalingPlugin().onInvitationTimeout(callbackID);
      _zegoUikitRn.default.getSignalingPlugin().onInvitationAccepted(callbackID);
      _zegoUikitRn.default.getSignalingPlugin().onInvitationRefused(callbackID);
      _zegoUikitRn.default.getSignalingPlugin().onInRoomTextMessageReceived(callbackID);
    }
  };
  const initDialogTimer = () => {
    clearInterval(hideCountdownOn_DialogTimer.current);
    hideCountdownOn_DialogTimer.current = null;
    hideCountdownOn_Dialog.current = hideCountdownOnDialogLimit;
  };
  const startDialogTimer = () => {
    clearInterval(hideCountdownOn_DialogTimer.current);
    hideCountdownOn_DialogTimer.current = setInterval(() => {
      if (hideCountdownOn_Dialog.current === 0) {
        setIsDialogVisableHandle(false);
      } else {
        hideCountdownOn_Dialog.current -= 1;
      }
    }, 1000);
  };
  const setIsDialogVisableHandle = visable => {
    if (visable) {
      startDialogTimer();
    } else {
      initDialogTimer();
      setDialogExtendedData({});
      stateData.current.dialogExtendedData = {};
    }
    _prebuilt_helper.default.getInstance().notifyZegoDialogTrigger(visable);
    stateData.current.isDialogVisable = visable;
  };
  const startLiveStreamingTimingTimer = (0, _react.useCallback)(function () {
    let restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    console.log('######startLiveStreamingTimingTimer########');
    if (!isVisible) return;
    const temp = () => {
      liveStreamingTimingTimer.current = setInterval(() => {
        console.log('########liveStreamingTimingTimer timing', liveStreamingTiming.current);
        liveStreamingTiming.current += 1;
        setDuration(liveStreamingTiming.current);
        stateData.current.duration = liveStreamingTiming.current;
        typeof onDurationUpdate === 'function' && onDurationUpdate(liveStreamingTiming.current);
      }, 1000);
      stateData.current.liveStreamingTimingTimer = liveStreamingTimingTimer.current;
    };
    if (restart) {
      console.log('########liveStreamingTimingTimer restart timing', liveStreamingTiming.current);
      clearInterval(liveStreamingTimingTimer.current);
      temp();
    } else {
      if (liveStreamingTimingTimer.current) {
        // Avoid double timing
        console.log('########liveStreamingTimingTimer double timing', liveStreamingTiming.current);
      } else {
        console.log('########startLiveStreamingTimingTimer');
        initLiveStreamingTimingTimer();
        temp();
      }
    }
  }, []);
  isMinimizeSwitch && startLiveStreamingTimingTimer(true);
  const initLiveStreamingTimingTimer = () => {
    console.log('########initLiveStreamingTimingTimer');
    clearInterval(liveStreamingTimingTimer.current);
    liveStreamingTimingTimer.current = null;
    liveStreamingTiming.current = 0;
    setDuration(0);
    stateData.current.duration = 0;
    stateData.current.liveStreamingTimingTimer = null;
  };
  (0, _react.useImperativeHandle)(ref, () => ({
    leave: async function () {
      let showConfirmation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (debounce.current) return;
      if (!showConfirmation) {
        debounce.current = true;
        await tempHandle();
        _zegoUikitRn.default.leaveRoom();
        typeof onLeaveLiveStreaming == 'function' && onLeaveLiveStreaming(liveStreamingTiming.current);
        debounce.current = false;
      } else {
        debounce.current = true;
        onLeaveLiveStreamingConfirmingWrap(onLeaveLiveStreamingConfirming).then(() => {
          _zegoUikitRn.default.leaveRoom();
          typeof onLeaveLiveStreaming == 'function' && onLeaveLiveStreaming(liveStreamingTiming.current);
          debounce.current = false;
        });
      }
    },
    minimizeWindow: () => {
      _minimizing_helper.default.getInstance().minimizeWindow();
    }
  }));
  (0, _react.useEffect)(() => {
    _zegoUikitRn.default.onRoomStateChanged(callbackID, () => {
      if (_zegoUikitRn.default.isRoomConnected()) {
        // Anchor set host
        console.log('########onRoomStateChanged anchor set host', realTimeData.current);
        if (realTimeData.current.role === _defines.ZegoLiveStreamingRole.host && !realTimeData.current.hostID) {
          _zegoUikitRn.default.updateRoomProperties({
            host: userID,
            live_status: `${_defines.ZegoLiveStatus.default}`
          });
          // Unequal results update the local value first
          setHostID(userID);
          realTimeData.current.hostID = userID;
          stateData.current.hostID = userID;

          // @ts-ignore
          setLiveStatus(_defines.ZegoLiveStatus.default);
          realTimeData.current.liveStatus = _defines.ZegoLiveStatus.default;
          stateData.current.liveStatus = _defines.ZegoLiveStatus.default;
          console.log('########onRoomStateChanged anchor set host end', realTimeData.current);
        }
      }
    });
    _zegoUikitRn.default.onUserJoin(callbackID, () => {
      const count = _zegoUikitRn.default.getAllUsers().length;
      stateData.current.memberCount = count;
      setMemberCount(count);
    });
    _zegoUikitRn.default.onUserLeave(callbackID, () => {
      const count = _zegoUikitRn.default.getAllUsers().length;
      stateData.current.memberCount = count;
      setMemberCount(count);
    });
    _zegoUikitRn.default.onRoomPropertiesFullUpdated(callbackID, (keys, oldRoomProperties, roomProperties, type) => {
      console.log('########onRoomPropertiesFullUpdated', keys, oldRoomProperties, roomProperties, type);
    });
    _zegoUikitRn.default.onRoomPropertyUpdated(callbackID, (key, oldValue, value, type) => {
      console.log('########onRoomPropertyUpdated', key, oldValue, value, type);
      // Resolved callback delay in receiving room attached message
      if (realTimeData.current.role === _defines.ZegoLiveStreamingRole.host && type === _zegoUikitRn.ZegoRoomPropertyUpdateType.remote) {
        // Set again, update uikit data
        console.log('########Set again, update uikit data', userID, realTimeData.current.liveStatus);
        isIgnore.current = true;
        _zegoUikitRn.default.updateRoomProperties({
          host: userID,
          live_status: `${realTimeData.current.liveStatus}`
        });
        return;
      }
      if (isIgnore.current) {
        console.log('########onRoomPropertyUpdated ignore');
        isIgnore.current = false;
        return;
      }
      if (key === 'host') {
        setHostID(value);
        realTimeData.current.hostID = value;
        stateData.current.hostID = value;
      } else if (key === 'live_status') {
        let temp = value ? parseInt(value) : '';
        if (temp === _defines.ZegoLiveStatus.default) {
          // The live_status is set to 0 before the host enters the room
          console.log('########onRoomPropertyUpdated Update the reorder identity', true);
          if (realTimeData.current.role !== _defines.ZegoLiveStreamingRole.host) {
            // When the audience character receives the broadcast notification, stop pull all streams
            // Uikit is also pulled by default, so you have to stop here as well
            _zegoUikitRn.default.stopPlayingAllAudioVideo();
            if (oldValue === `${_defines.ZegoLiveStatus.start}`) {
              // Hide the host's invitation to cohost dialog
              setIsDialogVisableHandle(false);
              initLiveStreamingTimingTimer();

              // Cancel the invitation to cohost
              _zegoUikitRn.default.getSignalingPlugin().cancelInvitation([realTimeData.current.hostID]);
              _zegoUikitRn.default.turnCameraOn('', false);
              _zegoUikitRn.default.turnMicrophoneOn('', false);

              // Update role and memberConnectStateMap
              setRole(_defines.ZegoLiveStreamingRole.audience);
              realTimeData.current.role = _defines.ZegoLiveStreamingRole.audience;
              stateData.current.role = _defines.ZegoLiveStreamingRole.audience;
              realTimeData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
              stateData.current.memberConnectStateMap[userID] = _defines.ZegoCoHostConnectState.idle;
              setMemberConnectStateMap({
                ...realTimeData.current.memberConnectStateMap
              });
              typeof onLiveStreamingEnded === 'function' && onLiveStreamingEnded(liveStreamingTiming.current);
            }
          }
        } else {
          // The launch needs to be sorted, with the owner at the top of the list
          shouldSortHostAtFirst.current = true;
          _zegoUikitRn.default.forceSortAudioVideoList();
          _zegoUikitRn.default.startPlayingAllAudioVideo();
        }

        // @ts-ignore
        setLiveStatus(temp);
        if (temp === _defines.ZegoLiveStatus.start) {
          startLiveStreamingTimingTimer();
        }
        realTimeData.current.liveStatus = temp;
        stateData.current.liveStatus = temp;
      }
    });
    _zegoUikitRn.default.onUserInfoUpdate(callbackID, userInfo => {
      // This callback is executed before onAudioVideoAvailable and onAudioVideoUnavailable
      const {
        userID,
        isMicDeviceOn,
        isCameraDeviceOn
      } = userInfo;
      if (userID === realTimeData.current.hostID && !isMicDeviceOn && !isCameraDeviceOn) {
        // Host turn off their cameras and microphones, cohost will fill in the bit, so it needs to be reordered next time
        console.log('########onAudioVideoUnavailable Update the reorder identity', true);
        shouldSortHostAtFirst.current = true;
      }
    });
    _zegoUikitRn.default.onAudioVideoAvailable(callbackID, userList => {
      console.log('########onAudioVideoAvailable', userList);
      userList.forEach(userInfo => {
        // Not in memberConnectStateMap but already connected
        if (realTimeData.current.hostID !== userInfo.userID) {
          realTimeData.current.memberConnectStateMap[userInfo.userID] = _defines.ZegoCoHostConnectState.connected;
          stateData.current.memberConnectStateMap[userInfo.userID] = _defines.ZegoCoHostConnectState.connected;
          setMemberConnectStateMap({
            ...realTimeData.current.memberConnectStateMap
          });
        }
      });
    });
    _zegoUikitRn.default.onAudioVideoUnavailable(callbackID, userList => {
      userList.forEach(userInfo => {
        if (userInfo.userID === realTimeData.current.hostID) {
          // Host turn off their cameras and microphones, cohost will fill in the bit, so it needs to be reordered next time
          // Move to the onUserInfoUpdate callback for processing
        } else {
          if (userInfo.userID !== userID) {
            realTimeData.current.memberConnectStateMap[userInfo.userID] = _defines.ZegoCoHostConnectState.idle;
            stateData.current.memberConnectStateMap[userInfo.userID] = _defines.ZegoCoHostConnectState.idle;
            setMemberConnectStateMap({
              ...realTimeData.current.memberConnectStateMap
            });
          } else {
            // Do not deal with
          }
        }
      });
    });
    _zegoUikitRn.default.onTurnOnYourCameraRequest(callbackID, formUser => {
      console.log('########onTurnOnYourCameraRequest', formUser);
      onCameraTurnOnByOthersConfirmation && onCameraTurnOnByOthersConfirmation(formUser).then(async () => {
        // Allow to open
        try {
          await (0, _utils.grantPermissions)();
        } catch (error) {}
        _zegoUikitRn.default.turnCameraOn('', true);
      });
    });
    _zegoUikitRn.default.onTurnOnYourMicrophoneRequest(callbackID, formUser => {
      console.log('########onTurnOnYourMicrophoneRequest', formUser);
      onMicrophoneTurnOnByOthersConfirmation && onMicrophoneTurnOnByOthersConfirmation(formUser).then(async () => {
        // Allow to open
        try {
          await (0, _utils.grantPermissions)();
        } catch (error) {}
        _zegoUikitRn.default.turnMicrophoneOn('', true);
      });
    });
    _zegoUikitRn.default.onMeRemovedFromRoom(callbackID, () => {
      typeof onLeaveLiveStreaming == 'function' && onLeaveLiveStreaming(liveStreamingTiming.current);
    });
    _zegoUikitRn.default.onInRoomCommandReceived(callbackID, (fromUser, command) => {
      console.warn('[Prebuilt]onInRoomCommandReceived', fromUser, command);
    });
    _zegoUikitRn.default.onMicrophoneOn(callbackID, (targetUserID, isOn) => {
      if (targetUserID === userID) {
        console.log('onMicrophoneOn', targetUserID, isOn);
        stateData.current.turnOnMicrophoneWhenJoining = !!isOn;
      }
    });
    _zegoUikitRn.default.onCameraOn(callbackID, (targetUserID, isOn) => {
      if (targetUserID === userID) {
        console.log('onCameraOn', targetUserID, isOn);
        stateData.current.turnOnCameraWhenJoining = !!isOn;
      }
    });
    _zegoUikitRn.default.onAudioOutputDeviceChanged(callbackID, type => {
      console.log('onAudioOutputDeviceChanged', type);
      stateData.current.useSpeakerWhenJoining = type === 0;
    });
    _minimizing_helper.default.getInstance().onWindowMinimized(callbackID, () => {
      // Hidden input box
      setTextInputVisable(false);

      // Hide toast
      hideCountdownOnToast = hideCountdownOnToastLimit;
      setIsToastVisable(false);

      // Hide the invitation and remove box at the bottom
      setIsCoHostDialogVisable(false);
      setCoHostDialogExtendedData({});
    });

    // Initialize after use
    _minimizing_helper.default.getInstance().setIsMinimizeSwitch(false);
    return () => {
      const isMinimizeSwitch = _minimizing_helper.default.getInstance().getIsMinimizeSwitch();
      if (!isMinimizeSwitch) {
        _zegoUikitRn.default.onRoomStateChanged(callbackID);
        _zegoUikitRn.default.onUserJoin(callbackID);
        _zegoUikitRn.default.onUserLeave(callbackID);
        _zegoUikitRn.default.onRoomPropertiesFullUpdated(callbackID);
        _zegoUikitRn.default.onRoomPropertyUpdated(callbackID);
        _zegoUikitRn.default.onUserInfoUpdate(callbackID);
        _zegoUikitRn.default.onAudioVideoAvailable(callbackID);
        _zegoUikitRn.default.onAudioVideoUnavailable(callbackID);
        _zegoUikitRn.default.onTurnOnYourCameraRequest(callbackID);
        _zegoUikitRn.default.onTurnOnYourMicrophoneRequest(callbackID);
        _zegoUikitRn.default.onMeRemovedFromRoom(callbackID);
        _zegoUikitRn.default.onInRoomCommandReceived(callbackID);
        _prebuilt_helper.default.getInstance().clearRealTimeData();
        _prebuilt_helper.default.getInstance().clearState();
        _prebuilt_helper.default.getInstance().clearNotify();
      }
    };
  }, []);
  (0, _react.useEffect)(() => {
    _plugins.default.init(appID, appSign, userID, userName, plugins).then(result => {
      setIsPluginsInit(result);
      _minimizing_helper.default.getInstance().notifyPrebuiltInit();
      // Register plugin callback
      registerPluginCallback();
      _plugins.default.joinRoom(liveID).then(result => {
        if (result) {
          (0, _logger.zloginfo)('[ZegoUIKitPrebuiltLiveStreaming] join room success.');
        }
      });
      _zegoUikitRn.default.init(appID, appSign, {
        userID: userID,
        userName: userName
      }).then(() => {
        _zegoUikitRn.default.turnCameraOn('', turnOnCameraWhenJoining);
        _zegoUikitRn.default.turnMicrophoneOn('', turnOnMicrophoneWhenJoining);
        _zegoUikitRn.default.setAudioOutputToSpeaker(useSpeakerWhenJoining);
        if (config.role === _defines.ZegoLiveStreamingRole.host) {
          (0, _utils.grantPermissions)(() => {
            _zegoUikitRn.default.joinRoom(liveID, '', !!markAsLargeRoom);
          });
        } else {
          _zegoUikitRn.default.joinRoom(liveID, '', !!markAsLargeRoom);
        }
      });
    });
    // Initialize after use
    _minimizing_helper.default.getInstance().setIsMinimizeSwitch(false);
    return () => {
      const isMinimizeSwitch = _minimizing_helper.default.getInstance().getIsMinimizeSwitch();
      if (!isMinimizeSwitch) {
        setIsDialogVisableHandle(false);
        initLiveStreamingTimingTimer();
        _zegoUikitRn.default.leaveRoom();
        unRegisterPluginCallback();
        _plugins.default.uninit();
        _prebuilt_helper.default.getInstance().clearRealTimeData();
        _prebuilt_helper.default.getInstance().clearState();
        _prebuilt_helper.default.getInstance().clearNotify();
      }
    };
  }, []);
  const showAudioVideoContainer = () => {
    // @ts-ignore
    return role === _defines.ZegoLiveStreamingRole.host || role !== _defines.ZegoLiveStreamingRole.host && liveStatus === _defines.ZegoLiveStatus.start;
  };
  const showStartLiveButton = () => {
    // @ts-ignore
    return role === _defines.ZegoLiveStreamingRole.host && hostID && hostID === userID && liveStatus === _defines.ZegoLiveStatus.default;
  };
  const showBottomBar = () => {
    // @ts-ignore
    return role === _defines.ZegoLiveStreamingRole.host && hostID && hostID === userID && liveStatus === _defines.ZegoLiveStatus.start || role === _defines.ZegoLiveStreamingRole.audience || role === _defines.ZegoLiveStreamingRole.coHost;
  };
  const showMessageListView = () => {
    // @ts-ignore
    return role === _defines.ZegoLiveStreamingRole.host && liveStatus === _defines.ZegoLiveStatus.start || role !== _defines.ZegoLiveStreamingRole.host;
  };
  const onFullPageTouch = () => {
    console.log('####onFullPageTouch####');
    hideCountdownOnToast = hideCountdownOnToastLimit;
    setIsToastVisable(false);
    setTextInputVisable(false);
    setIsMemberListVisable(false);
    setIsCoHostDialogVisable(false);
    setCoHostDialogExtendedData({});
    setTextInputHeight(45); // It needs to be reinitialized, otherwise the height will be wrong

    stateData.current.isMemberListVisable = false;
  };
  const useInterval = (callback, delay) => {
    const savedCallback = (0, _react.useRef)();
    (0, _react.useEffect)(() => {
      savedCallback.current = callback;
    }, []);
    (0, _react.useEffect)(() => {
      function tick() {
        savedCallback.current();
      }
      if (delay !== null) {
        const id = setInterval(tick, delay);
        return () => clearInterval(id);
      }
    }, [delay]);
  };
  // Close toast on time
  useInterval(() => {
    hideCountdownOnToast--;
    if (hideCountdownOnToast <= 0) {
      hideCountdownOnToast = hideCountdownOnToastLimit;
      setIsToastVisable(false);
      setToastExtendedData({});
    }
  }, 1000);
  const getHostNameByID = hostID => {
    const userInfo = _zegoUikitRn.default.getUser(hostID) || {};
    const hostName = userInfo.userName || '';
    return hostName;
  };
  const onMemberButtonPressed = () => {
    setTextInputVisable(false);
    setIsMemberListVisable(true);
    stateData.current.isMemberListVisable = true;
  };
  const onNavBackPressed = () => {
    const leaveHandle = async () => {
      // Leave the room
      _zegoUikitRn.default.leaveRoom();
      typeof onLeaveLiveStreaming == 'function' && onLeaveLiveStreaming(liveStreamingTiming.current);
    };
    const temp = onLeaveLiveStreamingConfirmingWrap(onLeaveLiveStreamingConfirming);
    if (temp) {
      temp.then(() => {
        leaveHandle();
      });
    } else {
      // Reserve cases that do not require confirmation
      leaveHandle();
    }
  };
  const sortAudioVideo = globalAudioVideoUserList => {
    console.log('########sortAudioVideo', globalAudioVideoUserList, realTimeData.current.hostID, shouldSortHostAtFirst.current);
    const index = globalAudioVideoUserList.findIndex(userInfo => userInfo.userID === realTimeData.current.hostID);
    if (shouldSortHostAtFirst.current && index !== -1) {
      // Put host first
      const temp = globalAudioVideoUserList.splice(index, 1)[0];
      globalAudioVideoUserList.unshift(temp);
      // You don't have to deal with the sorting once, because the addition to the internal stream is also added to the end of the queue
      console.log('########sortAudioVideo Sort completion and update the reorder identity', false);
      shouldSortHostAtFirst.current = false;
    }
    return globalAudioVideoUserList;
  };
  const onStartLiveStreaming = () => {
    // After the host enters the room and sets the room properties successfully
    // The host receives the callback of the additional message of the room
    // You must also set the property host, otherwise host will be null
    _zegoUikitRn.default.updateRoomProperties({
      host: hostID,
      live_status: `${_defines.ZegoLiveStatus.start}`
    }).then(() => {
      typeof onStartLiveButtonPressed === 'function' && onStartLiveButtonPressed();
    });
  };
  const showDefaultLeaveDialog = () => {
    return new Promise((resolve, reject) => {
      if (!confirmDialogInfo) {
        resolve();
      } else {
        const {
          title = "Leave the live streaming",
          message = "Are you sure to leave the live streaming?",
          cancelButtonName = "Cancel",
          confirmButtonName = "Confirm"
        } = confirmDialogInfo;
        _reactNative.Alert.alert(title, message, [{
          text: cancelButtonName,
          onPress: () => reject(),
          style: "cancel"
        }, {
          text: confirmButtonName,
          onPress: () => resolve()
        }]);
      }
    });
  };
  const tempHandle = async () => {
    // Intercept confirm 
    if (role === _defines.ZegoLiveStreamingRole.host) {
      // @ts-ignore
      if (liveStatus === _defines.ZegoLiveStatus.start) {
        // Clear room properties
        await _zegoUikitRn.default.updateRoomProperties({
          live_status: `${_defines.ZegoLiveStatus.default}`,
          host: ''
        });
        typeof onLiveStreamingEnded === 'function' && onLiveStreamingEnded(liveStreamingTiming.current);
      } else {
        // Clear room properties
        await _zegoUikitRn.default.updateRoomProperties({
          live_status: `${_defines.ZegoLiveStatus.default}`,
          host: ''
        });
      }
    } else if (role === _defines.ZegoLiveStreamingRole.coHost) {} else {}
  };
  const onLeaveLiveStreamingConfirmingWrap = onLeaveLiveStreamingConfirming => {
    const temp = onLeaveLiveStreamingConfirming || showDefaultLeaveDialog;
    return new Promise((resolve, reject) => {
      temp().then(async () => {
        await tempHandle();
        resolve();
      }).catch(() => {
        // Intercept confirm cancel
        reject();
      });
    });
  };
  const connectStateChangedHandle = (changedUserID, connectState, isClosure) => {
    console.log('#########connectStateChangedHandle', changedUserID, connectState, memberConnectStateMap, realTimeData.current.memberConnectStateMap);
    // The audience connection status changes
    changedUserID = changedUserID || userID;
    const temp = connectState === _defines.ZegoCoHostConnectState.connected ? _defines.ZegoLiveStreamingRole.coHost : _defines.ZegoLiveStreamingRole.audience;
    if (!isClosure) {
      // Just take the value in state, because there's no closure
      memberConnectStateMap[changedUserID] = connectState;
      // Rerendering causes realTimeData.current to be empty, so a reassignment is required here
      role !== _defines.ZegoLiveStreamingRole.host && (realTimeData.current.role = temp, stateData.current.role = temp);
      realTimeData.current.memberConnectStateMap = {
        ...memberConnectStateMap
      };
      stateData.current.memberConnectStateMap = {
        ...memberConnectStateMap
      };
      role !== _defines.ZegoLiveStreamingRole.host && setRole(temp);
      setMemberConnectStateMap({
        ...memberConnectStateMap
      });
    } else {
      // There are closures, status values cannot be used directly
      realTimeData.current.memberConnectStateMap[changedUserID] = connectState;
      stateData.current.memberConnectStateMap[changedUserID] = connectState;
      setMemberConnectStateMap({
        ...realTimeData.current.memberConnectStateMap
      });
      if (realTimeData.current.role !== _defines.ZegoLiveStreamingRole.host) {
        setRole(temp);
        realTimeData.current.role = temp;
        stateData.current.role = temp;
      }
    }
  };
  const coHostDisagreeHandle = changedUserID => {
    // Just take the value in state, because there's no closure
    memberConnectStateMap[changedUserID] = _defines.ZegoCoHostConnectState.idle;

    // Rerendering causes realTimeData.current to be empty, so a reassignment is required here
    realTimeData.current.requestCoHostCount = requestCoHostCount - 1;
    stateData.current.requestCoHostCount = realTimeData.current.requestCoHostCount;
    realTimeData.current.memberConnectStateMap = {
      ...memberConnectStateMap
    };
    stateData.current.memberConnectStateMap = {
      ...memberConnectStateMap
    };
    setMemberConnectStateMap({
      ...memberConnectStateMap
    });
    setRequestCoHostCount(requestCoHostCount - 1);
  };
  const coHostAgreeHandle = changedUserID => {
    // Just take the value in state, because there's no closure
    memberConnectStateMap[changedUserID] = _defines.ZegoCoHostConnectState.connected;
    realTimeData.current.requestCoHostCount = requestCoHostCount - 1;
    stateData.current.requestCoHostCount = realTimeData.current.requestCoHostCount;
    realTimeData.current.memberConnectStateMap = {
      ...memberConnectStateMap
    };
    stateData.current.memberConnectStateMap = {
      ...memberConnectStateMap
    };
    setMemberConnectStateMap({
      ...memberConnectStateMap
    });
    setRequestCoHostCount(requestCoHostCount - 1);
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.container
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.fillParent
  }, /*#__PURE__*/_react.default.createElement(_zegoUikitRn.ZegoAudioVideoContainer, {
    audioVideoConfig: {
      showSoundWavesInAudioMode: showSoundWavesInAudioMode,
      useVideoViewAspectFill: useVideoViewAspectFill,
      cacheAudioVideoUserList: isMinimizeSwitch ? _zegoUikitRn.default.getAllUsers().filter(user => user.userID && (user.isCameraOn || user.isMicrophoneOn)) : null
    },
    layout: {
      mode: _zegoUikitRn.ZegoLayoutMode.pictureInPicture,
      removeViewWhenAudioVideoUnavailable: true
    },
    sortAudioVideo: sortAudioVideo,
    foregroundBuilder: foregroundBuilder || (_ref6 => {
      let {
        userInfo
      } = _ref6;
      return /*#__PURE__*/_react.default.createElement(_ZegoAudioVideoForegroundView.default, {
        role: role,
        userInfo: userInfo,
        localUserID: userID,
        turnOnCameraWhenJoining: turnOnCameraWhenJoining,
        turnOnMicrophoneWhenJoining: turnOnMicrophoneWhenJoining,
        showUserNameOnView: true,
        showCameraStateOnView: false,
        showMicrophoneStateOnView: true
      });
    })
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.fillParent, {
      zIndex: showAudioVideoContainer() ? -1 : 1
    }]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.ImageBackground, {
    style: styles.noHostBg,
    source: require('./resources/background.png')
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.noHostTips
  }, _defines.ZegoTranslationText.noHostOnline)))), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.topBarContainer
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.left
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.hostInfo, role === _defines.ZegoLiveStreamingRole.host && hostID && liveStatus === _defines.ZegoLiveStatus.start || role !== _defines.ZegoLiveStreamingRole.host && hostID ? styles.show : null]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.avatar
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.nameLabel
  }, (0, _utils.getShotName)(getHostNameByID(hostID)))), /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.hostName
  }, getHostNameByID(hostID))), /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    onPress: onNavBackPressed,
    style: [styles.navBackButton, role === _defines.ZegoLiveStreamingRole.host && hostID && liveStatus !== _defines.ZegoLiveStatus.start ? styles.show : null]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Image, {
    resizeMode: "contain",
    source: require('./resources/icon_nav_back.png')
  }))), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.right
  },
  // @ts-ignore
  role === _defines.ZegoLiveStreamingRole.host && liveStatus === _defines.ZegoLiveStatus.start || role !== _defines.ZegoLiveStreamingRole.host ? /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    onPress: onMemberButtonPressed
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.memberButton
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Image, {
    source: require('./resources/white_top_button_member.png')
  }), /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.memberCountLabel
  }, memberCount), requestCoHostCount ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.memberRedDot
  }) : null)) : null,
  // @ts-ignore
  role === _defines.ZegoLiveStreamingRole.host && liveStatus === _defines.ZegoLiveStatus.start || role !== _defines.ZegoLiveStreamingRole.host ? /*#__PURE__*/_react.default.createElement(_ZegoTopBar.default, {
    menuBarButtons: buttons,
    onLeave: () => {
      onLeaveLiveStreaming(liveStreamingTiming.current);
    },
    onLeaveConfirmation: onLeaveLiveStreamingConfirmingWrap.bind(this, onLeaveLiveStreamingConfirming)
  }) : null,
  // @ts-ignore
  role === _defines.ZegoLiveStreamingRole.host && hostID && hostID === userID && (liveStatus === _defines.ZegoLiveStatus.default || liveStatus === _defines.ZegoLiveStatus.default) ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.switchCameraButton
  }, /*#__PURE__*/_react.default.createElement(_zegoUikitRn.ZegoSwitchCameraButton, {
    iconFrontFacingCamera: require('./resources/icon_nav_flip.png'),
    iconBackFacingCamera: require('./resources/icon_nav_flip.png'),
    width: 36,
    height: 36
  })) : null)), showStartLiveButton() ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.startLiveButtonCon
  }, startLiveButtonBuilder ? startLiveButtonBuilder(onStartLiveStreaming) : /*#__PURE__*/_react.default.createElement(_ZegoStartLiveButton.default, {
    onPressed: onStartLiveStreaming
  })) : null,
  // @ts-ignore
  isVisible && liveStatus === _defines.ZegoLiveStatus.start ? /*#__PURE__*/_react.default.createElement(_reactNative.SafeAreaView, {
    style: styles.timingContainer
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: styles.timing
  }, (0, _utils.durationFormat)(duration))) : null, showMessageListView() ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.messageListView
  }, /*#__PURE__*/_react.default.createElement(_zegoUikitRn.ZegoInRoomMessageView, {
    itemBuilder: messageItemBuilder,
    style: styles.fillParent
  })) : null, isMemberListVisable ? /*#__PURE__*/_react.default.createElement(_ZegoLiveStreamingMemberList.default, {
    isPluginsInit: isPluginsInit,
    showMicrophoneState: showMicrophoneState,
    showCameraState: showCameraState,
    itemBuilder: itemBuilder,
    onCloseMemberList: () => {
      setIsMemberListVisable(false);
      stateData.current.isMemberListVisable = false;
    },
    hostID: hostID,
    memberCount: memberCount,
    memberConnectStateMap: memberConnectStateMap,
    onCoHostDisagree: coHostDisagreeHandle,
    onCoHostAgree: coHostAgreeHandle,
    onConnectStateChanged: connectStateChangedHandle,
    setIsToastVisable: visable => setIsToastVisable(visable),
    setToastExtendedData: toastExtendedData => setToastExtendedData(toastExtendedData),
    setIsCoHostDialogVisable: visable => setIsCoHostDialogVisable(visable),
    setCoHostDialogExtendedData: coHostDialogExtendedData => setCoHostDialogExtendedData(coHostDialogExtendedData)
  }) : null, /*#__PURE__*/_react.default.createElement(_ZegoCoHostMenuDialog.default, {
    visable: isCoHostDialogVisable,
    inviteeID: coHostDialogExtendedData.inviteeID,
    invitationType: coHostDialogExtendedData.invitationType,
    onCancel: coHostDialogExtendedData.onCancel,
    onOk: coHostDialogExtendedData.onOk,
    setIsToastVisable: visable => setIsToastVisable(visable),
    setToastExtendedData: toastExtendedData => setToastExtendedData(toastExtendedData),
    resetTimer: coHostDialogExtendedData.resetTimer
  }), /*#__PURE__*/_react.default.createElement(_ZegoToast.default, {
    visable: isToastVisable,
    text: toastExtendedData.text,
    type: toastExtendedData.type
  }), /*#__PURE__*/_react.default.createElement(_ZegoDialog.default, {
    title: dialogExtendedData.title,
    content: dialogExtendedData.content,
    cancelText: dialogExtendedData.cancelText,
    okText: dialogExtendedData.okText,
    onCancel: dialogExtendedData.onCancel,
    onOk: dialogExtendedData.onOk
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    pointerEvents: "auto",
    onTouchStart: onFullPageTouch,
    style: [styles.dismissArea, {
      bottom: (_reactNative.Platform.OS == 'ios' ? keyboardHeight + textInputHeight : textInputHeight) + 40
    }]
  }), showBottomBar() ? /*#__PURE__*/_react.default.createElement(_reactNative.KeyboardAvoidingView, {
    style: [styles.fillParent, {
      zIndex: 9
    }],
    behavior: 'padding'
  }, _reactNative.Platform.OS != 'ios' && keyboardHeight > 0 ? null : /*#__PURE__*/_react.default.createElement(_ZegoBottomBar.default, {
    menuBarButtonsMaxCount: maxCount,
    menuBarButtons: role === _defines.ZegoLiveStreamingRole.host ? hostButtons : role === _defines.ZegoLiveStreamingRole.audience ? audienceButtons : role === _defines.ZegoLiveStreamingRole.coHost ? coHostButtons : [],
    menuBarExtendedButtons: role === _defines.ZegoLiveStreamingRole.host ? hostExtendButtons : role === _defines.ZegoLiveStreamingRole.audience ? audienceExtendButtons : role === _defines.ZegoLiveStreamingRole.coHost ? coHostExtendButtons : [],
    turnOnCameraWhenJoining: turnOnCameraWhenJoining,
    turnOnMicrophoneWhenJoining: turnOnMicrophoneWhenJoining,
    useSpeakerWhenJoining: useSpeakerWhenJoining,
    showInRoomMessageButton: showInRoomMessageButton,
    onLeaveLiveStreaming: () => {
      onLeaveLiveStreaming(liveStreamingTiming.current);
    }
    // @ts-ignore
    ,
    onLeaveLiveStreamingConfirming: onLeaveLiveStreamingConfirmingWrap.bind(this, onLeaveLiveStreamingConfirming),
    onMessageButtonPress: () => {
      setTextInputVisable(true);
    },
    onConnectStateChanged: connectStateChangedHandle,
    setIsToastVisable: visable => setIsToastVisable(visable),
    setToastExtendedData: toastExtendedData => setToastExtendedData(toastExtendedData),
    setIsDialogVisable: setIsDialogVisableHandle,
    setDialogExtendedData: dialogExtendedData => {
      setDialogExtendedData(dialogExtendedData);
      stateData.current.dialogExtendedData = dialogExtendedData;
    },
    isPluginsInit: isPluginsInit,
    userID: userID,
    hostID: hostID,
    liveStatus: liveStatus,
    memberConnectState: memberConnectStateMap[userID]
  }), textInputVisable ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.messageInputPannel, {
      bottom: _reactNative.Platform.OS == 'ios' ? keyboardHeight : 0,
      height: textInputHeight
    }]
  }, /*#__PURE__*/_react.default.createElement(_zegoUikitRn.ZegoInRoomMessageInput, {
    ref: input => {
      setTextInput(input);
    }
    // @ts-ignore
    ,
    onContentSizeChange: height => {
      // setTextInputHeight(height);
    },
    placeholder: 'Say something...',
    onSumit: () => {
      setTextInputVisable(false);
    }
  })) : null) : null);
}
var _default = /*#__PURE__*/(0, _react.forwardRef)(ZegoUIKitPrebuiltLiveStreaming);
exports.default = _default;
const styles = _reactNative.StyleSheet.create({
  messageListView: {
    position: 'absolute',
    left: 16,
    bottom: 80,
    width: 270,
    maxHeight: 200,
    zIndex: 12
  },
  messageInputPannel: {
    position: 'absolute',
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.7500)',
    width: '100%',
    zIndex: 11
  },
  container: {
    flex: 1,
    position: 'absolute',
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 0
  },
  fillParent: {
    width: '100%',
    height: '100%',
    position: 'absolute'
  },
  topBarContainer: {
    position: 'absolute',
    top: 32,
    zIndex: 10,
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
    justifyContent: 'space-between',
    paddingTop: 3,
    paddingBottom: 3
  },
  left: {
    flexDirection: 'row',
    alignItems: "center"
  },
  right: {
    flexDirection: 'row',
    alignItems: "center"
  },
  hostInfo: {
    flexDirection: 'row',
    backgroundColor: 'rgba(30, 39, 64, 0.4)',
    borderRadius: 1000,
    paddingLeft: 3,
    paddingRight: 12,
    paddingTop: 3,
    paddingBottom: 3,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16,
    display: 'none'
  },
  show: {
    display: 'flex'
  },
  avatar: {
    backgroundColor: '#ffffff',
    borderRadius: 1000,
    width: 28,
    height: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 6,
    marginLeft: 3
  },
  nameLabel: {
    fontSize: 18,
    color: '#2A2A2A'
  },
  hostName: {
    color: '#FFFFFF',
    fontSize: 14
  },
  navBackButton: {
    marginLeft: 20,
    display: 'none',
    paddingLeft: 6,
    paddingRight: 6,
    paddingTop: 6,
    paddingBottom: 6
  },
  leaveButton: {
    marginRight: 10
  },
  switchCameraButton: {
    marginRight: 16
  },
  memberButton: {
    width: 53,
    height: 28,
    backgroundColor: 'rgba(30, 39, 64, 0.4000)',
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 17,
    marginRight: 2
  },
  memberCountLabel: {
    fontSize: 14,
    color: 'white',
    marginLeft: 3
  },
  memberRedDot: {
    backgroundColor: '#FF0D23',
    borderRadius: 1000,
    width: 8,
    height: 8,
    position: 'absolute',
    right: 0,
    top: 0
  },
  startLiveButtonCon: {
    position: 'absolute',
    width: '100%',
    zIndex: 12,
    bottom: 48.5,
    alignItems: 'center'
  },
  dismissArea: {
    zIndex: 11,
    width: '100%',
    top: 80,
    position: 'absolute'
  },
  noHostBg: {
    flex: 1,
    resizeMode: 'cover',
    justifyContent: 'center',
    alignItems: 'center'
  },
  noHostTips: {
    width: 330,
    height: 90,
    fontSize: 14,
    lineHeight: 45,
    color: 'white',
    textAlign: 'center'
  },
  timingContainer: {
    position: 'absolute',
    top: 6,
    zIndex: 11
  },
  timing: {
    color: 'white'
  }
});
//# sourceMappingURL=index.js.map