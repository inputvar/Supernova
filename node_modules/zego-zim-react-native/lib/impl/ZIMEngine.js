import { NativeModules, NativeEventEmitter } from 'react-native';
import { ZIMManager } from './ZIMManager';
import { ZIMLogger, ZIMLogTag, ZIMLogAction } from './ZIMLogger';
import { ZIMParamValid } from './ZIMParamValid';
import { ZIMMessageType, ZIMMessageDirection, } from '../ZIMDefines';
const { ZIMNativeModule } = NativeModules;
const Prefix = ZIMNativeModule.prefix;
const ZIMEvent = new NativeEventEmitter(ZIMNativeModule);
const NOOP = () => { };
export function createSymbol() {
    return Symbol(Math.random().toString(16)).toString();
}
export class ZIMEngine {
    constructor(handle, appID, appSign) {
        this.loginUserID = '';
        this.handle = handle;
        this.appID = appID;
        this.appSign = appSign;
        this.logger = new ZIMLogger();
        this.paramValid = new ZIMParamValid(this.logger);
        this.uploadingMap = new Map();
        this.downloadingMap = new Map();
        this.messageAttachedMap = new Map();
        this.eventNameList = [
            'error',
            'connectionStateChanged',
            'tokenWillExpire',
            'conversationChanged',
            'conversationTotalUnreadMessageCountUpdated',
            'conversationMessageReceiptChanged',
            'messageReceiptChanged',
            'messageRevokeReceived',
            'messageReactionsChanged',
            'messageSentStatusChanged',
            'receivePeerMessage',
            'receiveGroupMessage',
            'receiveRoomMessage',
            'broadcastMessageReceived',
            'messageAttached',
            'mediaUploadingProgress',
            'mediaDownloadingProgress',
            'roomStateChanged',
            'roomMemberJoined',
            'roomMemberLeft',
            'roomAttributesUpdated',
            'roomAttributesBatchUpdated',
            'roomMemberAttributesUpdated',
            'groupStateChanged',
            'groupNameUpdated',
            'groupAvatarUrlUpdated',
            'groupNoticeUpdated',
            'groupAttributesUpdated',
            'groupMemberStateChanged',
            'groupMemberInfoUpdated',
            'callInvitationReceived',
            'callInvitationCancelled',
            'callInvitationTimeout',
            'callInvitationEnded',
            'callUserStateChanged',
            'callInvitationAccepted',
            'callInvitationRejected',
            'callInviteesAnsweredTimeout',
        ];
        this.create();
    }
    create() {
        ZIMNativeModule.setAdvancedConfig('zim_cross_platform', 'react-native');
        ZIMNativeModule.createEngine(this.handle, this.appID, this.appSign);
    }
    handleReject(err) {
        const error = err && err.code ? { code: +err.code, message: err.message } : err;
        throw error;
    }
    destroy() {
        for (const event of this.eventNameList) {
            ZIMEvent.removeAllListeners(Prefix + event);
        }
        this.uploadingMap.clear();
        this.downloadingMap.clear();
        this.messageAttachedMap.clear();
        ZIMNativeModule.destroyEngine(this.handle);
    }
    uploadLog() {
        return ZIMNativeModule.uploadLog(this.handle);
    }
    on(type, listener) {
        if (!listener || typeof listener != 'function')
            throw new Error('listener must be a function.');
        this.off(type);
        const native_listener = (res) => {
            try {
                const { handle, data } = res;
                this.logger.warn('', 'JSAPI.emit.' + type, data);
                const engine = ZIMManager.engineMap.get(handle);
                // @ts-ignore
                listener(engine, data);
            }
            catch (error) { }
        };
        ZIMEvent.addListener(Prefix + type, native_listener);
        this.logger.warn('', 'JSAPI.on.' + type);
    }
    off(type) {
        ZIMEvent.removeAllListeners(Prefix + type);
    }
    // MARK: - Main
    login(userInfo, token) {
        const error = this.paramValid.login(userInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.login(this.handle, userInfo, token).then(() => (this.loginUserID = userInfo.userID));
    }
    logout() {
        return ZIMNativeModule.logout(this.handle);
    }
    renewToken(token) {
        return ZIMNativeModule.renewToken(this.handle, token).catch(this.handleReject);
    }
    queryUsersInfo(userIDs, config) {
        const error = this.paramValid.queryUsersInfo(userIDs);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isQueryFromServer: false }, config);
        return ZIMNativeModule.queryUsersInfo(this.handle, userIDs, config).catch(this.handleReject);
    }
    updateUserName(userName) {
        const error = this.paramValid.validName('userName', userName, ZIMLogTag.User, ZIMLogAction.UpdateUserName);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserName(this.handle, userName).catch(this.handleReject);
    }
    updateUserAvatarUrl(userAvatarUrl) {
        const error = this.paramValid.validName('userAvatarUrl', userAvatarUrl, ZIMLogTag.User, ZIMLogAction.UpdateUserAvatarUrl);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserAvatarUrl(this.handle, userAvatarUrl).catch(this.handleReject);
    }
    updateUserExtendedData(extendedData) {
        const error = this.paramValid.validName('extendedData', extendedData, ZIMLogTag.User, ZIMLogAction.UpdateUserExtendedData);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateUserExtendedData(this.handle, extendedData).catch(this.handleReject);
    }
    // MARK: - Conversation
    queryConversation(conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.QueryConversation);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryConversation(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    queryConversationList(config) {
        const error = this.paramValid.queryConversationList(config, ZIMLogAction.QueryConversationList);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationList: [] });
        return ZIMNativeModule.queryConversationList(this.handle, config).catch(this.handleReject);
    }
    queryConversationPinnedList(config) {
        const error = this.paramValid.queryConversationList(config, ZIMLogAction.QueryPinnedList);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationList: [] });
        return ZIMNativeModule.queryConversationPinnedList(this.handle, config).catch(this.handleReject);
    }
    deleteConversation(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.DeleteConversation);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isAlsoDeleteServerConversation: true }, config);
        return ZIMNativeModule.deleteConversation(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    setConversationNotificationStatus(status, conversationID, conversationType) {
        const error = this.paramValid.setNotificationStatus(status, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setConversationNotificationStatus(this.handle, status, conversationID, conversationType).catch(this.handleReject);
    }
    updateConversationPinnedState(isPinned, conversationID, conversationType) {
        const error = this.paramValid.updatePinnedState(isPinned, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateConversationPinnedState(this.handle, isPinned, conversationID, conversationType).catch(this.handleReject);
    }
    clearConversationUnreadMessageCount(conversationID, conversationType) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.ClearUnreadMessageCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.clearConversationUnreadMessageCount(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    sendMessage(message, toConversationID, conversationType, config, notification) {
        const error = this.paramValid.sendMessage(message, toConversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ hasReceipt: false }, config);
        const _handle = createSymbol();
        const messageAttachedCallBack = (notification && notification.onMessageAttached) || NOOP;
        const native_messageAttached_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                Object.assign(message, data[0]);
                const listener = this.messageAttachedMap.get(handle);
                listener && listener(message);
            }
        };
        const attached_sub = ZIMEvent.addListener(Prefix + 'messageAttached', native_messageAttached_listener);
        this.messageAttachedMap.set(_handle, messageAttachedCallBack);
        // Uint8Array -> String
        const _message = { ...message };
        if (_message.type == ZIMMessageType.Command) {
            _message.message = _message.message.toString();
        }
        return ZIMNativeModule.sendMessage(this.handle, _message, toConversationID, conversationType, config, _handle)
            .then((result) => {
            attached_sub.remove();
            this.messageAttachedMap.delete(_handle);
            return { message: Object.assign(message, result.message) };
        })
            .catch((err) => {
            attached_sub.remove();
            this.messageAttachedMap.delete(_handle);
            this.handleReject(err);
        });
    }
    sendMediaMessage(message, toConversationID, conversationType, config, notification) {
        const error = this.paramValid.sendMediaMessage(message, toConversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ hasReceipt: false }, config);
        const _handle = createSymbol();
        const progressCallBack = (notification && notification.onMediaUploadingProgress) || NOOP;
        const native_progress_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                data[0] = Object.assign(message, data[0]);
                const listener = this.uploadingMap.get(handle);
                // @ts-ignore
                listener && listener(...data);
            }
        };
        const progress_sub = ZIMEvent.addListener(Prefix + 'mediaUploadingProgress', native_progress_listener);
        this.uploadingMap.set(_handle, progressCallBack);
        const messageAttachedCallBack = (notification && notification.onMessageAttached) || NOOP;
        const native_messageAttached_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                Object.assign(message, data[0]);
                const listener = this.messageAttachedMap.get(handle);
                listener && listener(message);
            }
        };
        const attached_sub = ZIMEvent.addListener(Prefix + 'messageAttached', native_messageAttached_listener);
        this.messageAttachedMap.set(_handle, messageAttachedCallBack);
        return ZIMNativeModule.sendMediaMessage(this.handle, { ...message }, toConversationID, conversationType, config, _handle, _handle)
            .then((result) => {
            progress_sub.remove();
            attached_sub.remove();
            this.uploadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            return { message: Object.assign(message, result.message) };
        })
            .catch((err) => {
            progress_sub.remove();
            attached_sub.remove();
            this.uploadingMap.delete(_handle);
            this.messageAttachedMap.delete(_handle);
            this.handleReject(err);
        });
    }
    deleteMessages(messageList, conversationID, conversationType, config) {
        config = Object.assign({ isAlsoDeleteServerMessage: true }, config);
        const error = this.paramValid.deleteMessages(messageList, conversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        if (!messageList.length && !config.isAlsoDeleteServerMessage)
            return Promise.resolve({ conversationID, conversationType });
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        return ZIMNativeModule.deleteMessages(this.handle, messageList, conversationID, conversationType, config).catch(this.handleReject);
    }
    deleteAllMessage(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.DeleteAllMessage);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ isAlsoDeleteServerMessage: true }, config);
        return ZIMNativeModule.deleteAllMessage(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    queryHistoryMessage(conversationID, conversationType, config) {
        const error = this.paramValid.queryHistoryMessage(conversationID, conversationType, config);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ conversationID, conversationType, messageList: [] });
        // nextMessage can not be online message
        if (config &&
            config.nextMessage &&
            (config.nextMessage.type == ZIMMessageType.Command || config.nextMessage.type == ZIMMessageType.Barrage)) {
            config = { ...config };
            config.nextMessage = void 0;
        }
        return ZIMNativeModule.queryHistoryMessage(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    downloadMediaFile(message, fileType, progress) {
        const error = this.paramValid.downloadMediaFile(message, fileType);
        if (error)
            return Promise.reject(error);
        const _handle = createSymbol();
        const native_progress_listener = (res) => {
            const { handle, data } = res;
            if (handle == _handle) {
                const listener = this.downloadingMap.get(handle);
                // @ts-ignore
                listener && listener && listener(...data);
            }
        };
        const progress_sub = ZIMEvent.addListener(Prefix + 'mediaDownloadingProgress', native_progress_listener);
        this.downloadingMap.set(_handle, progress);
        return ZIMNativeModule.downloadMediaFile(this.handle, message, fileType, _handle)
            .then((result) => {
            progress_sub.remove();
            this.downloadingMap.delete(_handle);
            return result;
        })
            .catch((err) => {
            progress_sub.remove();
            this.downloadingMap.delete(_handle);
            this.handleReject(err);
        });
    }
    insertMessageToLocalDB(message, conversationID, conversationType, senderUserID) {
        const error = this.paramValid.insertMessageToLocalDB(message, conversationID, conversationType, senderUserID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.insertMessageToLocalDB(this.handle, { ...message }, conversationID, conversationType, senderUserID)
            .then((result) => {
            return { message: Object.assign(message, result.message) };
        })
            .catch(this.handleReject);
    }
    updateMessageLocalExtendedData(localExtendedData, message) {
        const error = this.paramValid.updateMessageLocalExtendedData(localExtendedData, message);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateMessageLocalExtendedData(this.handle, localExtendedData, { ...message })
            .then((result) => {
            return { message: Object.assign(message, result.message) };
        })
            .catch(this.handleReject);
    }
    revokeMessage(message, config) {
        const error = this.paramValid.revokeMessage(message);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.revokeMessage(this.handle, message, config).catch(this.handleReject);
    }
    // MARK: - Message receipt
    sendConversationMessageReceiptRead(conversationID, conversationType) {
        const error = this.paramValid.sendReceiptRead(conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.sendConversationMessageReceiptRead(this.handle, conversationID, conversationType).catch(this.handleReject);
    }
    sendMessageReceiptsRead(messageList, conversationID, conversationType) {
        const error = this.paramValid.sendMessageReceiptsRead(messageList, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        return ZIMNativeModule.sendMessageReceiptsRead(this.handle, messageList, conversationID, conversationType).catch(this.handleReject);
    }
    queryMessageReceiptsInfo(messageList, conversationID, conversationType) {
        const error = this.paramValid.queryReceiptsInfo(messageList, conversationID, conversationType);
        if (error)
            return Promise.reject(error);
        // Filter online message
        messageList = messageList.filter((msg) => msg.type != ZIMMessageType.Command && msg.type != ZIMMessageType.Barrage);
        return ZIMNativeModule.queryMessageReceiptsInfo(this.handle, messageList, conversationID, conversationType).catch(this.handleReject);
    }
    queryGroupMessageReceiptMemberList(message, groupID, config, read) {
        const error = this.paramValid.queryReceiptMemberList(message, groupID, config, read, this.loginUserID);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0 || message.direction == ZIMMessageDirection.Receive) {
            return Promise.resolve({ groupID, nextFlag: 0, userList: [] });
        }
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryGroupMessageReceiptMemberList(this.handle, message, groupID, config, read).catch(this.handleReject);
    }
    // MARK: - Message reaction
    addMessageReaction(reactionType, message) {
        const error = this.paramValid.messageReaction(reactionType, message, true);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.addMessageReaction(this.handle, reactionType, message).catch(this.handleReject);
    }
    deleteMessageReaction(reactionType, message) {
        const error = this.paramValid.messageReaction(reactionType, message);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteMessageReaction(this.handle, reactionType, message).catch(this.handleReject);
    }
    queryMessageReactionUserList(message, config) {
        const error = this.paramValid.queryMessageReactionUserList(message, config);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0) {
            const res = { totalCount: 0, nextFlag: 0, reactionType: config.reactionType, userList: [], message };
            return Promise.resolve(res);
        }
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryMessageReactionUserList(this.handle, message, config).catch(this.handleReject);
    }
    // MARK: - Room
    createRoom(roomInfo, config) {
        const error = this.paramValid.createRoom(roomInfo, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.createRoom(this.handle, roomInfo, config).catch(this.handleReject);
    }
    enterRoom(roomInfo, config) {
        const error = this.paramValid.createRoom(roomInfo, config, true);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.enterRoom(this.handle, roomInfo, config).catch(this.handleReject);
    }
    joinRoom(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.JoinRoom);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.joinRoom(this.handle, roomID).catch(this.handleReject);
    }
    leaveRoom(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.LeaveRoom);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.leaveRoom(this.handle, roomID).catch(this.handleReject);
    }
    queryRoomMemberList(roomID, config) {
        const error = this.paramValid.queryRoomMemberList(roomID, config);
        if (error)
            return Promise.reject(error);
        if (config.count < 1)
            return Promise.resolve({ roomID, memberList: [], nextFlag: '' });
        return ZIMNativeModule.queryRoomMemberList(this.handle, roomID, config).catch(this.handleReject);
    }
    queryRoomMembers(userIDs, roomID) {
        const error = this.paramValid.queryRoomMembers(userIDs, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomMembers(this.handle, userIDs, roomID).catch(this.handleReject);
    }
    queryRoomOnlineMemberCount(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomOnlineMemberCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomOnlineMemberCount(this.handle, roomID).catch(this.handleReject);
    }
    queryRoomAllAttributes(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomAllAttributes);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomAllAttributes(this.handle, roomID).catch(this.handleReject);
    }
    setRoomAttributes(roomAttributes, roomID, config) {
        const error = this.paramValid.setRoomAttributes(roomAttributes, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setRoomAttributes(this.handle, roomAttributes, roomID, config).catch(this.handleReject);
    }
    deleteRoomAttributes(keys, roomID, config) {
        const error = this.paramValid.deleteRoomAttributes(keys, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteRoomAttributes(this.handle, keys, roomID, config).catch(this.handleReject);
    }
    beginRoomAttributesBatchOperation(roomID, config) {
        ZIMNativeModule.beginRoomAttributesBatchOperation(this.handle, roomID, config);
    }
    endRoomAttributesBatchOperation(roomID) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.EndRoomAttributesBatchOperation);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.endRoomAttributesBatchOperation(this.handle, roomID).catch(this.handleReject);
    }
    setRoomMembersAttributes(attributes, userIDs, roomID, config) {
        const error = this.paramValid.setRoomMembersAttributes(attributes, userIDs, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setRoomMembersAttributes(this.handle, attributes, userIDs, roomID, config).catch(this.handleReject);
    }
    queryRoomMembersAttributes(userIDs, roomID) {
        const error = this.paramValid.queryRoomMembersAttributes(userIDs, roomID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryRoomMembersAttributes(this.handle, userIDs, roomID).catch(this.handleReject);
    }
    queryRoomMemberAttributesList(roomID, config) {
        const error = this.paramValid.validID('roomID', roomID, ZIMLogTag.Room, ZIMLogAction.QueryRoomMemberAttributesList);
        if (error)
            return Promise.reject(error);
        if (config && config.count < 1)
            return Promise.resolve({ roomID, nextFlag: '', infos: [] });
        return ZIMNativeModule.queryRoomMemberAttributesList(this.handle, roomID, config).catch(this.handleReject);
    }
    // MARK: - Group
    createGroup(groupInfo, userIDs, config) {
        groupInfo = Object.assign({ groupID: '', groupName: '', groupAvatarUrl: '' }, groupInfo);
        config = Object.assign({ groupAttributes: {}, groupNotice: '' }, config);
        const error = this.paramValid.createGroup(groupInfo, userIDs, config);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.createGroup(this.handle, groupInfo, userIDs, config).catch(this.handleReject);
    }
    joinGroup(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.JoinGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.joinGroup(this.handle, groupID).catch(this.handleReject);
    }
    leaveGroup(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.LeaveGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.leaveGroup(this.handle, groupID).catch(this.handleReject);
    }
    dismissGroup(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.DismissGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.dismissGroup(this.handle, groupID).catch(this.handleReject);
    }
    queryGroupList() {
        return ZIMNativeModule.queryGroupList(this.handle).catch(this.handleReject);
    }
    updateGroupName(groupName, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupName', groupName, ZIMLogTag.Group, ZIMLogAction.UpdateGroupName);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupName(this.handle, groupName, groupID).catch(this.handleReject);
    }
    updateGroupNotice(groupNotice, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupNotice', groupNotice, ZIMLogTag.Group, ZIMLogAction.UpdateGroupNotice);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupNotice(this.handle, groupNotice, groupID).catch(this.handleReject);
    }
    updateGroupAvatarUrl(groupAvatarUrl, groupID) {
        const error = this.paramValid.validIDAndName('groupID', groupID, 'groupAvatarUrl', groupAvatarUrl, ZIMLogTag.Group, ZIMLogAction.UpdateGroupAvatarUrl);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.updateGroupAvatarUrl(this.handle, groupAvatarUrl, groupID).catch(this.handleReject);
    }
    queryGroupInfo(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupInfo(this.handle, groupID).catch(this.handleReject);
    }
    setGroupAttributes(groupAttributes, groupID) {
        const error = this.paramValid.setGroupAttributes(groupAttributes, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupAttributes(this.handle, groupAttributes, groupID).catch(this.handleReject);
    }
    deleteGroupAttributes(keys, groupID) {
        const error = this.paramValid.deleteGroupAttributes(keys, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.deleteGroupAttributes(this.handle, keys, groupID).catch(this.handleReject);
    }
    queryGroupAttributes(keys, groupID) {
        const error = this.paramValid.queryGroupAttributes(groupID, keys);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupAttributes(this.handle, keys, groupID).catch(this.handleReject);
    }
    queryGroupAllAttributes(groupID) {
        const error = this.paramValid.queryGroupAttributes(groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupAllAttributes(this.handle, groupID).catch(this.handleReject);
    }
    setGroupMemberNickname(nickname, forUserID, groupID) {
        const error = this.paramValid.setGroupMemberNickname(nickname, forUserID, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupMemberNickname(this.handle, nickname, forUserID, groupID).catch(this.handleReject);
    }
    setGroupMemberRole(role, forUserID, groupID) {
        const error = this.paramValid.setGroupMemberRole(role, forUserID, groupID);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.setGroupMemberRole(this.handle, role, forUserID, groupID).catch(this.handleReject);
    }
    transferGroupOwner(toUserID, groupID) {
        const error = this.paramValid.validTwoID('toUserID', toUserID, 'groupID', groupID, ZIMLogTag.Group, ZIMLogAction.TransferGroupOwner);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.transferGroupOwner(this.handle, toUserID, groupID).catch(this.handleReject);
    }
    queryGroupMemberInfo(userID, groupID) {
        const error = this.paramValid.validTwoID('userID', userID, 'groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberInfo);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupMemberInfo(this.handle, userID, groupID).catch(this.handleReject);
    }
    inviteUsersIntoGroup(userIDs, groupID) {
        const error = this.paramValid.validGroupUserIDs(userIDs, groupID, ZIMLogAction.InviteUsersIntoGroup);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.inviteUsersIntoGroup(this.handle, userIDs, groupID).catch(this.handleReject);
    }
    kickGroupMembers(userIDs, groupID) {
        const error = this.paramValid.validGroupUserIDs(userIDs, groupID, ZIMLogAction.KickGroupMembers);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.kickGroupMembers(this.handle, userIDs, groupID).catch(this.handleReject);
    }
    queryGroupMemberList(groupID, config) {
        config = Object.assign({ count: 100, nextFlag: 0 }, config);
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberList);
        if (error)
            return Promise.reject(error);
        if (config.count < 1 || config.nextFlag < 0)
            return Promise.resolve({ groupID, userList: [], nextFlag: 0 });
        return ZIMNativeModule.queryGroupMemberList(this.handle, groupID, config).catch(this.handleReject);
    }
    queryGroupMemberCount(groupID) {
        const error = this.paramValid.validID('groupID', groupID, ZIMLogTag.Group, ZIMLogAction.QueryGroupMemberCount);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.queryGroupMemberCount(this.handle, groupID).catch(this.handleReject);
    }
    // MARK: - Call
    callInvite(invitees, config) {
        const error = this.paramValid.callInvite(invitees, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ mode: 0, timeout: 90 }, config);
        if (config.pushConfig) {
            config.pushConfig.payload = config.pushConfig.payload || '';
            config.pushConfig.resourcesID = config.pushConfig.resourcesID || '';
        }
        return ZIMNativeModule.callInvite(this.handle, invitees, config).catch(this.handleReject);
    }
    callCancel(invitees, callID, config) {
        const error = this.paramValid.callIDAndInvitees(invitees, callID, ZIMLogAction.CallCancel);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callCancel(this.handle, invitees, callID, config).catch(this.handleReject);
    }
    callAccept(callID, config) {
        const error = this.paramValid.validID('callID', callID, ZIMLogTag.Call, ZIMLogAction.CallAccept);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callAccept(this.handle, callID, config).catch(this.handleReject);
    }
    callReject(callID, config) {
        const error = this.paramValid.validID('callID', callID, ZIMLogTag.Call, ZIMLogAction.CallReject);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callReject(this.handle, callID, config).catch(this.handleReject);
    }
    callQuit(callID, config) {
        const error = this.paramValid.validID('callID', callID, ZIMLogTag.Call, ZIMLogAction.CallQuit);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callQuit(this.handle, callID, config).catch(this.handleReject);
    }
    callEnd(callID, config) {
        const error = this.paramValid.validID('callID', callID, ZIMLogTag.Call, ZIMLogAction.CallEnd);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callEnd(this.handle, callID, config).catch(this.handleReject);
    }
    callingInvite(invitees, callID, config) {
        const error = this.paramValid.callIDAndInvitees(invitees, callID, ZIMLogAction.CallingInvite);
        if (error)
            return Promise.reject(error);
        return ZIMNativeModule.callingInvite(this.handle, invitees, callID, config).catch(this.handleReject);
    }
    queryCallInvitationList(config) {
        if (!config.count || config.count < 1)
            return Promise.resolve({ callList: [], nextFlag: 0 });
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.queryCallInvitationList(this.handle, config).catch(this.handleReject);
    }
    // MARK: - DB Search
    searchConversations(config) {
        const error = this.paramValid.searchConversations(config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0, startTime: 0, endTime: 0 }, config);
        return ZIMNativeModule.searchConversations(this.handle, config).catch(this.handleReject);
    }
    searchGlobalMessages(config) {
        const error = this.paramValid.searchMessages(config, ZIMLogAction.SearchGlobalMessages);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ order: 0, startTime: 0, endTime: 0 }, config);
        // nextMessage can not be online message
        if (config.nextMessage &&
            (config.nextMessage.type == ZIMMessageType.Command || config.nextMessage.type == ZIMMessageType.Barrage)) {
            config.nextMessage = void 0;
        }
        return ZIMNativeModule.searchGlobalMessages(this.handle, config).catch(this.handleReject);
    }
    searchMessages(conversationID, conversationType, config) {
        const error = this.paramValid.validConvIDAndType(conversationID, conversationType, ZIMLogAction.SearchMessages) ||
            this.paramValid.searchMessages(config, ZIMLogAction.SearchMessages);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ order: 0, startTime: 0, endTime: 0 }, config);
        // nextMessage can not be online message
        if (config.nextMessage &&
            (config.nextMessage.type == ZIMMessageType.Command || config.nextMessage.type == ZIMMessageType.Barrage)) {
            config.nextMessage = void 0;
        }
        return ZIMNativeModule.searchMessages(this.handle, conversationID, conversationType, config).catch(this.handleReject);
    }
    searchGroups(config) {
        const error = this.paramValid.searchGroups(config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.searchGroups(this.handle, config).catch(this.handleReject);
    }
    searchGroupMembers(groupID, config) {
        const error = this.paramValid.searchGroupMembers(groupID, config);
        if (error)
            return Promise.reject(error);
        config = Object.assign({ nextFlag: 0 }, config);
        return ZIMNativeModule.searchGroupMembers(this.handle, groupID, config).catch(this.handleReject);
    }
}
