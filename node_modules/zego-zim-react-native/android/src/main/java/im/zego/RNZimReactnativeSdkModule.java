package im.zego;

import android.app.Application;
import android.util.Log;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import im.zego.zim.ZIM;
import im.zego.zim.callback.ZIMCallAcceptanceSentCallback;
import im.zego.zim.callback.ZIMCallCancelSentCallback;
import im.zego.zim.callback.ZIMCallEndSentCallback;
import im.zego.zim.callback.ZIMCallInvitationListQueriedCallback;
import im.zego.zim.callback.ZIMCallInvitationSentCallback;
import im.zego.zim.callback.ZIMCallQuitSentCallback;
import im.zego.zim.callback.ZIMCallRejectionSentCallback;
import im.zego.zim.callback.ZIMCallingInvitationSentCallback;
import im.zego.zim.callback.ZIMConversationDeletedCallback;
import im.zego.zim.callback.ZIMConversationListQueriedCallback;
import im.zego.zim.callback.ZIMConversationMessageReceiptReadSentCallback;
import im.zego.zim.callback.ZIMConversationNotificationStatusSetCallback;
import im.zego.zim.callback.ZIMConversationPinnedListQueriedCallback;
import im.zego.zim.callback.ZIMConversationPinnedStateUpdatedCallback;
import im.zego.zim.callback.ZIMConversationQueriedCallback;
import im.zego.zim.callback.ZIMConversationUnreadMessageCountClearedCallback;
import im.zego.zim.callback.ZIMConversationsSearchedCallback;
import im.zego.zim.callback.ZIMEventHandler;
import im.zego.zim.callback.ZIMGroupAttributesOperatedCallback;
import im.zego.zim.callback.ZIMGroupAttributesQueriedCallback;
import im.zego.zim.callback.ZIMGroupAvatarUrlUpdatedCallback;
import im.zego.zim.callback.ZIMGroupCreatedCallback;
import im.zego.zim.callback.ZIMGroupDismissedCallback;
import im.zego.zim.callback.ZIMGroupInfoQueriedCallback;
import im.zego.zim.callback.ZIMGroupJoinedCallback;
import im.zego.zim.callback.ZIMGroupLeftCallback;
import im.zego.zim.callback.ZIMGroupListQueriedCallback;
import im.zego.zim.callback.ZIMGroupMemberCountQueriedCallback;
import im.zego.zim.callback.ZIMGroupMemberInfoQueriedCallback;
import im.zego.zim.callback.ZIMGroupMemberKickedCallback;
import im.zego.zim.callback.ZIMGroupMemberListQueriedCallback;
import im.zego.zim.callback.ZIMGroupMemberNicknameUpdatedCallback;
import im.zego.zim.callback.ZIMGroupMemberRoleUpdatedCallback;
import im.zego.zim.callback.ZIMGroupMembersSearchedCallback;
import im.zego.zim.callback.ZIMGroupMessageReceiptMemberListQueriedCallback;
import im.zego.zim.callback.ZIMGroupNameUpdatedCallback;
import im.zego.zim.callback.ZIMGroupNoticeUpdatedCallback;
import im.zego.zim.callback.ZIMGroupOwnerTransferredCallback;
import im.zego.zim.callback.ZIMGroupUsersInvitedCallback;
import im.zego.zim.callback.ZIMGroupsSearchedCallback;
import im.zego.zim.callback.ZIMLogUploadedCallback;
import im.zego.zim.callback.ZIMLoggedInCallback;
import im.zego.zim.callback.ZIMMediaDownloadedCallback;
import im.zego.zim.callback.ZIMMediaMessageSentCallback;
import im.zego.zim.callback.ZIMMessageDeletedCallback;
import im.zego.zim.callback.ZIMMessageInsertedCallback;
import im.zego.zim.callback.ZIMMessageLocalExtendedDataUpdatedCallback;
import im.zego.zim.callback.ZIMMessageQueriedCallback;
import im.zego.zim.callback.ZIMMessageReactionAddedCallback;
import im.zego.zim.callback.ZIMMessageReactionDeletedCallback;
import im.zego.zim.callback.ZIMMessageReactionUserListQueriedCallback;
import im.zego.zim.callback.ZIMMessageReceiptsInfoQueriedCallback;
import im.zego.zim.callback.ZIMMessageReceiptsReadSentCallback;
import im.zego.zim.callback.ZIMMessageRevokedCallback;
import im.zego.zim.callback.ZIMMessageSentCallback;
import im.zego.zim.callback.ZIMMessagesGlobalSearchedCallback;
import im.zego.zim.callback.ZIMMessagesSearchedCallback;
import im.zego.zim.callback.ZIMRoomAttributesBatchOperatedCallback;
import im.zego.zim.callback.ZIMRoomAttributesOperatedCallback;
import im.zego.zim.callback.ZIMRoomAttributesQueriedCallback;
import im.zego.zim.callback.ZIMRoomCreatedCallback;
import im.zego.zim.callback.ZIMRoomEnteredCallback;
import im.zego.zim.callback.ZIMRoomJoinedCallback;
import im.zego.zim.callback.ZIMRoomLeftCallback;
import im.zego.zim.callback.ZIMRoomMemberAttributesListQueriedCallback;
import im.zego.zim.callback.ZIMRoomMemberQueriedCallback;
import im.zego.zim.callback.ZIMRoomMembersAttributesOperatedCallback;
import im.zego.zim.callback.ZIMRoomMembersAttributesQueriedCallback;
import im.zego.zim.callback.ZIMRoomMembersQueriedCallback;
import im.zego.zim.callback.ZIMRoomOnlineMemberCountQueriedCallback;
import im.zego.zim.callback.ZIMTokenRenewedCallback;
import im.zego.zim.callback.ZIMUserAvatarUrlUpdatedCallback;
import im.zego.zim.callback.ZIMUserExtendedDataUpdatedCallback;
import im.zego.zim.callback.ZIMUserNameUpdatedCallback;
import im.zego.zim.callback.ZIMUsersInfoQueriedCallback;
import im.zego.zim.entity.ZIMAppConfig;
import im.zego.zim.entity.ZIMCacheConfig;
import im.zego.zim.entity.ZIMCallAcceptConfig;
import im.zego.zim.entity.ZIMCallCancelConfig;
import im.zego.zim.entity.ZIMCallEndConfig;
import im.zego.zim.entity.ZIMCallEndedSentInfo;
import im.zego.zim.entity.ZIMCallInfo;
import im.zego.zim.entity.ZIMCallInvitationAcceptedInfo;
import im.zego.zim.entity.ZIMCallInvitationCancelledInfo;
import im.zego.zim.entity.ZIMCallInvitationEndedInfo;
import im.zego.zim.entity.ZIMCallInvitationQueryConfig;
import im.zego.zim.entity.ZIMCallInvitationReceivedInfo;
import im.zego.zim.entity.ZIMCallInvitationRejectedInfo;
import im.zego.zim.entity.ZIMCallInvitationSentInfo;
import im.zego.zim.entity.ZIMCallInvitationTimeoutInfo;
import im.zego.zim.entity.ZIMCallInviteConfig;
import im.zego.zim.entity.ZIMCallQuitConfig;
import im.zego.zim.entity.ZIMCallQuitSentInfo;
import im.zego.zim.entity.ZIMCallRejectConfig;
import im.zego.zim.entity.ZIMCallUserInfo;
import im.zego.zim.entity.ZIMCallUserStateChangeInfo;
import im.zego.zim.entity.ZIMCallingInvitationSentInfo;
import im.zego.zim.entity.ZIMCallingInviteConfig;
import im.zego.zim.entity.ZIMConversation;
import im.zego.zim.entity.ZIMConversationChangeInfo;
import im.zego.zim.entity.ZIMConversationDeleteConfig;
import im.zego.zim.entity.ZIMConversationQueryConfig;
import im.zego.zim.entity.ZIMConversationSearchConfig;
import im.zego.zim.entity.ZIMConversationSearchInfo;
import im.zego.zim.entity.ZIMError;
import im.zego.zim.entity.ZIMErrorUserInfo;
import im.zego.zim.entity.ZIMGroup;
import im.zego.zim.entity.ZIMGroupAdvancedConfig;
import im.zego.zim.entity.ZIMGroupAttributesUpdateInfo;
import im.zego.zim.entity.ZIMGroupFullInfo;
import im.zego.zim.entity.ZIMGroupInfo;
import im.zego.zim.entity.ZIMGroupMemberInfo;
import im.zego.zim.entity.ZIMGroupMemberQueryConfig;
import im.zego.zim.entity.ZIMGroupMemberSearchConfig;
import im.zego.zim.entity.ZIMGroupMessageReceiptMemberQueryConfig;
import im.zego.zim.entity.ZIMGroupOperatedInfo;
import im.zego.zim.entity.ZIMGroupSearchConfig;
import im.zego.zim.entity.ZIMGroupSearchInfo;
import im.zego.zim.entity.ZIMLogConfig;
import im.zego.zim.entity.ZIMMediaMessage;
import im.zego.zim.entity.ZIMMessage;
import im.zego.zim.entity.ZIMMessageDeleteConfig;
import im.zego.zim.entity.ZIMMessageQueryConfig;
import im.zego.zim.entity.ZIMMessageReaction;
import im.zego.zim.entity.ZIMMessageReactionUserInfo;
import im.zego.zim.entity.ZIMMessageReactionUserQueryConfig;
import im.zego.zim.entity.ZIMMessageReceiptInfo;
import im.zego.zim.entity.ZIMMessageRevokeConfig;
import im.zego.zim.entity.ZIMMessageSearchConfig;
import im.zego.zim.entity.ZIMMessageSendConfig;
import im.zego.zim.entity.ZIMMessageSentStatusChangeInfo;
import im.zego.zim.entity.ZIMPushConfig;
import im.zego.zim.entity.ZIMRevokeMessage;
import im.zego.zim.entity.ZIMRoomAdvancedConfig;
import im.zego.zim.entity.ZIMRoomAttributesBatchOperationConfig;
import im.zego.zim.entity.ZIMRoomAttributesDeleteConfig;
import im.zego.zim.entity.ZIMRoomAttributesSetConfig;
import im.zego.zim.entity.ZIMRoomAttributesUpdateInfo;
import im.zego.zim.entity.ZIMRoomFullInfo;
import im.zego.zim.entity.ZIMRoomInfo;
import im.zego.zim.entity.ZIMRoomMemberAttributesInfo;
import im.zego.zim.entity.ZIMRoomMemberAttributesOperatedInfo;
import im.zego.zim.entity.ZIMRoomMemberAttributesQueryConfig;
import im.zego.zim.entity.ZIMRoomMemberAttributesSetConfig;
import im.zego.zim.entity.ZIMRoomMemberAttributesUpdateInfo;
import im.zego.zim.entity.ZIMRoomMemberInfo;
import im.zego.zim.entity.ZIMRoomMemberQueryConfig;
import im.zego.zim.entity.ZIMRoomOperatedInfo;
import im.zego.zim.entity.ZIMUserFullInfo;
import im.zego.zim.entity.ZIMUserInfo;
import im.zego.zim.entity.ZIMUsersInfoQueryConfig;
import im.zego.zim.enums.ZIMCallInvitationMode;
import im.zego.zim.enums.ZIMConnectionEvent;
import im.zego.zim.enums.ZIMConnectionState;
import im.zego.zim.enums.ZIMConversationNotificationStatus;
import im.zego.zim.enums.ZIMConversationType;
import im.zego.zim.enums.ZIMErrorCode;
import im.zego.zim.enums.ZIMGroupEvent;
import im.zego.zim.enums.ZIMGroupMemberEvent;
import im.zego.zim.enums.ZIMGroupMemberState;
import im.zego.zim.enums.ZIMGroupState;
import im.zego.zim.enums.ZIMMediaFileType;
import im.zego.zim.enums.ZIMMessageOrder;
import im.zego.zim.enums.ZIMMessagePriority;
import im.zego.zim.enums.ZIMMessageType;
import im.zego.zim.enums.ZIMRoomEvent;
import im.zego.zim.enums.ZIMRoomState;
import im.zego.zim.internal.util.ZIMLogUtil;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.json.JSONObject;

public class RNZimReactnativeSdkModule extends ReactContextBaseJavaModule {

    private static final String Prefix = "im.zego.zim.reactnative.";

    private final ReactApplicationContext reactContext;

    private HashMap<String, ZIM> engineMap;
    private HashMap<ZIM, String> engineMapForCallback;

    public RNZimReactnativeSdkModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
        this.engineMap = new HashMap<>();
        this.engineMapForCallback = new HashMap<>();
    }

    @Override
    public String getName() {
        return "RCTZIMNativeModule";
    }

    @Override
    public Map<String, Object> getConstants() {
        final Map<String, Object> constants = new HashMap<>();
        constants.put("prefix", Prefix);
        return constants;
    }

    // Used for passive call
    private void sendEvent(String eventName, WritableMap dataMap, ZIM zim) {
        WritableMap paramsMap = Arguments.createMap();
        paramsMap.putString("handle", this.engineMapForCallback.get(zim));
        paramsMap.putMap("data", dataMap);

        this.reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
            .emit(Prefix + eventName, paramsMap);
    }

    // Used for API active call
    private void sendAPIEvent(String eventName, WritableMap params) {
        this.reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
            .emit(Prefix + eventName, params);
    }

    @ReactMethod
    public void addListener(String eventName) {}

    @ReactMethod
    public void removeListeners(Integer count) {}

    @ReactMethod
    public void getVersion(final Promise promise) {
        promise.resolve(ZIM.getVersion());
    }

    @ReactMethod
    public void writeCustomLog(String customLog, String moduleName) {
        try {
            // Class<?> clz = Class.forName("im.zego.zim.internal.util.ZIMLogUtil");
            Class<ZIMLogUtil> clz = ZIMLogUtil.class;
            Method method = clz.getDeclaredMethod("writeCustomLog", String.class, String.class);
            method.setAccessible(true);
            method.invoke(null, customLog, moduleName);
            method.setAccessible(false);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @ReactMethod
    public void setLogConfig(ReadableMap config) {
        ZIMLogConfig configObj = new ZIMLogConfig();
        if (config.hasKey("logPath")) {
            configObj.logPath = config.getString("logPath");
        }

        if (config.hasKey("logSize")) {
            configObj.logSize = Double.valueOf(config.getDouble("logSize")).longValue();
        }

        ZIM.setLogConfig(configObj);
    }

    @ReactMethod
    public void setCacheConfig(ReadableMap config) {
        ZIMCacheConfig configObj = new ZIMCacheConfig();
        if (config.hasKey("cachePath")) {
            configObj.cachePath = config.getString("cachePath");
        }

        ZIM.setCacheConfig(configObj);
    }

    @ReactMethod
    public void setAdvancedConfig(String key, String value) {
        ZIM.setAdvancedConfig(key, value);
    }

    @ReactMethod
    public void createEngine(String handle, Double appID, String appSign) {
        ZIM oldZIM = ZIM.getInstance();
        if (oldZIM != null) {
            oldZIM.destroy();
        }

        ZIMAppConfig appConfig = new ZIMAppConfig();
        appConfig.appID = appID.longValue();
        appConfig.appSign = appSign;

        ZIM zim = ZIM.create(appConfig, (Application) this.reactContext.getApplicationContext());
        if (zim != null) {
            this.engineMap.put(handle, zim);
            this.engineMapForCallback.put(zim, handle);

            zim.setEventHandler(
                new ZIMEventHandler() {
                    @Override
                    public void onError(ZIM zim, ZIMError errorInfo) {
                        super.onError(zim, errorInfo);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("code", errorInfo.code.value());
                        dataMap.putString("message", errorInfo.message);

                        sendEvent("error", dataMap, zim);
                    }

                    @Override
                    public void onConnectionStateChanged(
                        ZIM zim,
                        ZIMConnectionState state,
                        ZIMConnectionEvent event,
                        JSONObject extendedData
                    ) {
                        super.onConnectionStateChanged(zim, state, event, extendedData);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("state", state.value());
                        dataMap.putInt("event", event.value());
                        dataMap.putString("extendedData", extendedData.toString());

                        sendEvent("connectionStateChanged", dataMap, zim);
                    }

                    @Override
                    public void onTokenWillExpire(ZIM zim, int second) {
                        super.onTokenWillExpire(zim, second);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("second", second);

                        sendEvent("tokenWillExpire", dataMap, zim);
                    }

                    @Override
                    public void onConversationChanged(
                        ZIM zim,
                        ArrayList<ZIMConversationChangeInfo> conversationChangeInfoList
                    ) {
                        super.onConversationChanged(zim, conversationChangeInfoList);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putArray(
                            "infoList",
                            RNZIMConverter.convertConversationChangeInfoFromJavaToJs(conversationChangeInfoList)
                        );

                        sendEvent("conversationChanged", dataMap, zim);
                    }

                    @Override
                    public void onConversationTotalUnreadMessageCountUpdated(ZIM zim, int totalUnreadMessageCount) {
                        super.onConversationTotalUnreadMessageCountUpdated(zim, totalUnreadMessageCount);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("totalUnreadMessageCount", totalUnreadMessageCount);

                        sendEvent("conversationTotalUnreadMessageCountUpdated", dataMap, zim);
                    }

                    @Override
                    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
                        super.onReceivePeerMessage(zim, messageList, fromUserID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("fromConversationID", fromUserID);
                        dataMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));

                        sendEvent("receivePeerMessage", dataMap, zim);
                    }

                    @Override
                    public void onReceiveRoomMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromRoomID) {
                        super.onReceiveRoomMessage(zim, messageList, fromRoomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("fromConversationID", fromRoomID);
                        dataMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));

                        sendEvent("receiveRoomMessage", dataMap, zim);
                    }

                    @Override
                    public void onReceiveGroupMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromGroupID) {
                        super.onReceiveGroupMessage(zim, messageList, fromGroupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("fromConversationID", fromGroupID);
                        dataMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));

                        sendEvent("receiveGroupMessage", dataMap, zim);
                    }

                    @Override
                    public void onBroadcastMessageReceived(ZIM zim, ZIMMessage message) {
                        super.onBroadcastMessageReceived(zim, message);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putMap("message", RNZIMConverter.convertMessageFromJavaToJs(message));

                        sendEvent("broadcastMessageReceived", dataMap, zim);
                    }

                    @Override
                    public void onConversationMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
                        super.onConversationMessageReceiptChanged(zim, infos);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putArray("infos", RNZIMConverter.convertMessageReceiptInfoListFromJavaToJs(infos));

                        sendEvent("conversationMessageReceiptChanged", dataMap, zim);
                    }

                    @Override
                    public void onMessageReceiptChanged(ZIM zim, ArrayList<ZIMMessageReceiptInfo> infos) {
                        super.onMessageReceiptChanged(zim, infos);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putArray("infos", RNZIMConverter.convertMessageReceiptInfoListFromJavaToJs(infos));

                        sendEvent("messageReceiptChanged", dataMap, zim);
                    }

                    @Override
                    public void onMessageRevokeReceived(ZIM zim, ArrayList<ZIMRevokeMessage> messageList) {
                        super.onMessageRevokeReceived(zim, messageList);

                        WritableMap dataMap = Arguments.createMap();
                        WritableArray messageArray = Arguments.createArray();
                        for (ZIMMessage message : messageList) {
                            messageArray.pushMap(RNZIMConverter.convertMessageFromJavaToJs(message));
                        }
                        dataMap.putArray("messageList", messageArray);

                        sendEvent("messageRevokeReceived", dataMap, zim);
                    }

                    @Override
                    public void onMessageReactionsChanged(ZIM zim, ArrayList<ZIMMessageReaction> reactions) {
                        super.onMessageReactionsChanged(zim, reactions);

                        WritableMap dataMap = Arguments.createMap();
                        WritableArray infosArray = Arguments.createArray();
                        for (ZIMMessageReaction info : reactions) {
                            infosArray.pushMap(RNZIMConverter.convertMessageReactionFromJavaToJs(info));
                        }
                        dataMap.putArray("reactions", infosArray);

                        sendEvent("messageReactionsChanged", dataMap, zim);
                    }

                    @Override
                    public void onMessageSentStatusChanged(
                        ZIM zim,
                        ArrayList<ZIMMessageSentStatusChangeInfo> messageSentStatusChangeInfoList
                    ) {
                        super.onMessageSentStatusChanged(zim, messageSentStatusChangeInfoList);

                        WritableMap dataMap = Arguments.createMap();
                        WritableArray infosArray = Arguments.createArray();
                        for (ZIMMessageSentStatusChangeInfo info : messageSentStatusChangeInfoList) {
                            infosArray.pushMap(RNZIMConverter.convertMessageSentStatusChangeInfoFromJavaToJs(info));
                        }
                        dataMap.putArray("infos", infosArray);

                        sendEvent("messageSentStatusChanged", dataMap, zim);
                    }

                    @Override
                    public void onRoomMemberJoined(ZIM zim, ArrayList<ZIMUserInfo> memberList, String roomID) {
                        super.onRoomMemberJoined(zim, memberList, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("roomID", roomID);
                        dataMap.putArray("memberList", RNZIMConverter.convertUserInfoListFromJavaToJs(memberList));

                        sendEvent("roomMemberJoined", dataMap, zim);
                    }

                    @Override
                    public void onRoomMemberLeft(ZIM zim, ArrayList<ZIMUserInfo> memberList, String roomID) {
                        super.onRoomMemberLeft(zim, memberList, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("roomID", roomID);
                        dataMap.putArray("memberList", RNZIMConverter.convertUserInfoListFromJavaToJs(memberList));

                        sendEvent("roomMemberLeft", dataMap, zim);
                    }

                    @Override
                    public void onRoomStateChanged(
                        ZIM zim,
                        ZIMRoomState state,
                        ZIMRoomEvent event,
                        JSONObject extendedData,
                        String roomID
                    ) {
                        super.onRoomStateChanged(zim, state, event, extendedData, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("state", state.value());
                        dataMap.putInt("event", event.value());
                        dataMap.putString("extendedData", extendedData.toString());
                        dataMap.putString("roomID", roomID);

                        sendEvent("roomStateChanged", dataMap, zim);
                    }

                    @Override
                    public void onRoomAttributesUpdated(ZIM zim, ZIMRoomAttributesUpdateInfo info, String roomID) {
                        super.onRoomAttributesUpdated(zim, info, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("roomID", roomID);

                        WritableArray infoArray = Arguments.createArray();
                        WritableMap infoMap = Arguments.createMap();
                        WritableMap roomAttrMap = Arguments.createMap();
                        for (String key : info.roomAttributes.keySet()) {
                            roomAttrMap.putString(key, info.roomAttributes.get(key));
                        }
                        infoMap.putInt("action", info.action.value());
                        infoMap.putMap("roomAttributes", roomAttrMap);
                        infoArray.pushMap(infoMap);

                        dataMap.putArray("infos", infoArray);

                        sendEvent("roomAttributesUpdated", dataMap, zim);
                    }

                    @Override
                    public void onRoomAttributesBatchUpdated(
                        ZIM zim,
                        ArrayList<ZIMRoomAttributesUpdateInfo> infos,
                        String roomID
                    ) {
                        super.onRoomAttributesBatchUpdated(zim, infos, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("roomID", roomID);

                        WritableArray infoArray = Arguments.createArray();
                        for (ZIMRoomAttributesUpdateInfo info : infos) {
                            WritableMap infoMap = Arguments.createMap();
                            WritableMap roomAttrMap = Arguments.createMap();
                            for (String key : info.roomAttributes.keySet()) {
                                roomAttrMap.putString(key, info.roomAttributes.get(key));
                            }
                            infoMap.putInt("action", info.action.value());
                            infoMap.putMap("roomAttributes", roomAttrMap);
                            infoArray.pushMap(infoMap);
                        }

                        dataMap.putArray("infos", infoArray);

                        sendEvent("roomAttributesBatchUpdated", dataMap, zim);
                    }

                    @Override
                    public void onRoomMemberAttributesUpdated(
                        ZIM zim,
                        ArrayList<ZIMRoomMemberAttributesUpdateInfo> infos,
                        ZIMRoomOperatedInfo operatedInfo,
                        String roomID
                    ) {
                        super.onRoomMemberAttributesUpdated(zim, infos, operatedInfo, roomID);

                        WritableMap dataMap = Arguments.createMap();
                        ReadableArray infoArray = RNZIMConverter.convertRoomMemberAttributesUpdateInfoListFromJavaToJs(
                            infos
                        );
                        dataMap.putArray("infos", infoArray);
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertRoomOperatedInfoFromJavaToJs(operatedInfo)
                        );
                        dataMap.putString("roomID", roomID);

                        sendEvent("roomMemberAttributesUpdated", dataMap, zim);
                    }

                    @Override
                    public void onGroupStateChanged(
                        ZIM zim,
                        ZIMGroupState state,
                        ZIMGroupEvent event,
                        ZIMGroupOperatedInfo operatedInfo,
                        ZIMGroupFullInfo groupInfo
                    ) {
                        super.onGroupStateChanged(zim, state, event, operatedInfo, groupInfo);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("state", state.value());
                        dataMap.putInt("event", event.value());
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );
                        dataMap.putMap("groupInfo", RNZIMConverter.convertFullGroupInfoFromJavaToJs(groupInfo));

                        sendEvent("groupStateChanged", dataMap, zim);
                    }

                    @Override
                    public void onGroupNameUpdated(
                        ZIM zim,
                        String groupName,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupNameUpdated(zim, groupName, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("groupID", groupID);
                        dataMap.putString("groupName", groupName);
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );

                        sendEvent("groupNameUpdated", dataMap, zim);
                    }

                    @Override
                    public void onGroupAvatarUrlUpdated(
                        ZIM zim,
                        String groupAvatarUrl,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupAvatarUrlUpdated(zim, groupAvatarUrl, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("groupID", groupID);
                        dataMap.putString("groupAvatarUrl", groupAvatarUrl);
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );

                        sendEvent("groupAvatarUrlUpdated", dataMap, zim);
                    }

                    @Override
                    public void onGroupNoticeUpdated(
                        ZIM zim,
                        String groupNotice,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupNameUpdated(zim, groupNotice, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("groupID", groupID);
                        dataMap.putString("groupNotice", groupNotice);
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );

                        sendEvent("groupNoticeUpdated", dataMap, zim);
                    }

                    @Override
                    public void onGroupAttributesUpdated(
                        ZIM zim,
                        ArrayList<ZIMGroupAttributesUpdateInfo> infos,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupAttributesUpdated(zim, infos, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        WritableArray infoArray = Arguments.createArray();
                        for (ZIMGroupAttributesUpdateInfo info : infos) {
                            WritableMap infoMap = Arguments.createMap();
                            infoMap.putInt("action", info.action.value());

                            WritableMap groupAttrMap = Arguments.createMap();
                            for (String key : info.groupAttributes.keySet()) {
                                groupAttrMap.putString(key, info.groupAttributes.get(key));
                            }
                            infoMap.putMap("groupAttributes", groupAttrMap);

                            infoArray.pushMap(infoMap);
                        }
                        dataMap.putArray("infoList", infoArray);
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );
                        dataMap.putString("groupID", groupID);

                        sendEvent("groupAttributesUpdated", dataMap, zim);
                    }

                    @Override
                    public void onGroupMemberStateChanged(
                        ZIM zim,
                        ZIMGroupMemberState state,
                        ZIMGroupMemberEvent event,
                        ArrayList<ZIMGroupMemberInfo> userList,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupMemberStateChanged(zim, state, event, userList, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putInt("state", state.value());
                        dataMap.putInt("event", event.value());
                        dataMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );
                        dataMap.putString("groupID", groupID);

                        sendEvent("groupMemberStateChanged", dataMap, zim);
                    }

                    @Override
                    public void onGroupMemberInfoUpdated(
                        ZIM zim,
                        ArrayList<ZIMGroupMemberInfo> userList,
                        ZIMGroupOperatedInfo operatedInfo,
                        String groupID
                    ) {
                        super.onGroupMemberInfoUpdated(zim, userList, operatedInfo, groupID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));
                        dataMap.putMap(
                            "operatedInfo",
                            RNZIMConverter.convertGroupOperatedInfoFromJavaToJs(operatedInfo)
                        );
                        dataMap.putString("groupID", groupID);

                        sendEvent("groupMemberInfoUpdated", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationReceived(ZIM zim, ZIMCallInvitationReceivedInfo info, String callID) {
                        super.onCallInvitationReceived(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putString("inviter", info.inviter);
                        dataMap.putInt("timeout", info.timeout);
                        dataMap.putString("extendedData", info.extendedData);
                        dataMap.putInt("mode", info.mode.value());
                        dataMap.putString("caller", info.caller);
                        dataMap.putDouble("createTime", info.createTime);
                        dataMap.putArray(
                            "callUserList",
                            RNZIMConverter.convertCallUserListFromJavaToJs(info.callUserList)
                        );

                        sendEvent("callInvitationReceived", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationCancelled(ZIM zim, ZIMCallInvitationCancelledInfo info, String callID) {
                        super.onCallInvitationCancelled(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putString("inviter", info.inviter);
                        dataMap.putString("extendedData", info.extendedData);
                        dataMap.putInt("mode", info.mode.value());

                        sendEvent("callInvitationCancelled", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationTimeout(ZIM zim, ZIMCallInvitationTimeoutInfo info, String callID) {
                        super.onCallInvitationTimeout(zim, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putInt("mode", info.mode.value());

                        sendEvent("callInvitationTimeout", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationEnded(ZIM zim, ZIMCallInvitationEndedInfo info, String callID) {
                        super.onCallInvitationEnded(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putInt("mode", info.mode.value());
                        dataMap.putString("caller", info.caller);
                        dataMap.putString("operatedUserID", info.operatedUserID);
                        dataMap.putString("extendedData", info.extendedData);
                        dataMap.putDouble("endTime", info.endTime);

                        sendEvent("callInvitationEnded", dataMap, zim);
                    }

                    @Override
                    public void onCallUserStateChanged(ZIM zim, ZIMCallUserStateChangeInfo info, String callID) {
                        super.onCallUserStateChanged(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putArray(
                            "callUserList",
                            RNZIMConverter.convertCallUserListFromJavaToJs(info.callUserList)
                        );

                        sendEvent("callUserStateChanged", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationAccepted(ZIM zim, ZIMCallInvitationAcceptedInfo info, String callID) {
                        super.onCallInvitationAccepted(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putString("invitee", info.invitee);
                        dataMap.putString("extendedData", info.extendedData);

                        sendEvent("callInvitationAccepted", dataMap, zim);
                    }

                    @Override
                    public void onCallInvitationRejected(ZIM zim, ZIMCallInvitationRejectedInfo info, String callID) {
                        super.onCallInvitationRejected(zim, info, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        dataMap.putString("invitee", info.invitee);
                        dataMap.putString("extendedData", info.extendedData);

                        sendEvent("callInvitationRejected", dataMap, zim);
                    }

                    @Override
                    public void onCallInviteesAnsweredTimeout(ZIM zim, ArrayList<String> invitees, String callID) {
                        super.onCallInviteesAnsweredTimeout(zim, invitees, callID);

                        WritableMap dataMap = Arguments.createMap();
                        dataMap.putString("callID", callID);
                        WritableArray inviteesArray = Arguments.createArray();
                        for (String invitee : invitees) {
                            inviteesArray.pushString(invitee);
                        }
                        dataMap.putArray("invitees", inviteesArray);

                        sendEvent("callInviteesAnsweredTimeout", dataMap, zim);
                    }
                }
            );
        }
    }

    @ReactMethod
    public void destroyEngine(String handle) {
        ZIM zim = this.engineMap.get(handle);
        if (zim != null) {
            zim.destroy();

            this.engineMap.remove(handle);
            this.engineMapForCallback.remove(zim);
        }
    }

    @ReactMethod
    public void uploadLog(String handle, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.uploadLog(
            new ZIMLogUploadedCallback() {
                @Override
                public void onLogUploaded(ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        promise.resolve(null);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void login(String handle, ReadableMap userInfo, String token, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMUserInfo userInfoObj = new ZIMUserInfo();
        userInfoObj.userID = userInfo.getString("userID");
        userInfoObj.userName = userInfo.hasKey("userName") ? userInfo.getString("userName") : "";

        zim.login(
            userInfoObj,
            token,
            new ZIMLoggedInCallback() {
                @Override
                public void onLoggedIn(ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        promise.resolve(null);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void logout(String handle, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.logout();

        promise.resolve(null);
    }

    @ReactMethod
    public void renewToken(String handle, String token, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.renewToken(
            token,
            new ZIMTokenRenewedCallback() {
                @Override
                public void onTokenRenewed(String token, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("token", token);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryUsersInfo(String handle, ReadableArray userIDs, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userList = new ArrayList<>();
        for (Object userID : userIDs.toArrayList()) {
            userList.add((String) userID);
        }

        ZIMUsersInfoQueryConfig configObj = new ZIMUsersInfoQueryConfig();
        if (config != null) {
            configObj.isQueryFromServer =
                config.hasKey("isQueryFromServer") ? config.getBoolean("isQueryFromServer") : false;
        }

        zim.queryUsersInfo(
            userList,
            configObj,
            new ZIMUsersInfoQueriedCallback() {
                @Override
                public void onUsersInfoQueried(
                    ArrayList<ZIMUserFullInfo> userList,
                    ArrayList<ZIMErrorUserInfo> errorUserList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        WritableArray userInfoArray = Arguments.createArray();
                        for (ZIMUserFullInfo userInfo : userList) {
                            userInfoArray.pushMap(RNZIMConverter.convertUserFullInfoFromJavaToJs(userInfo));
                        }

                        returnMap.putArray("userList", userInfoArray);
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                        );

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateUserName(String handle, String userName, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateUserName(
            userName,
            new ZIMUserNameUpdatedCallback() {
                @Override
                public void onUserNameUpdated(String userName, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("userName", userName);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateUserAvatarUrl(String handle, String userAvatarUrl, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateUserAvatarUrl(
            userAvatarUrl,
            new ZIMUserAvatarUrlUpdatedCallback() {
                @Override
                public void onUserAvatarUrlUpdated(String userAvatarUrl, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("userAvatarUrl", userAvatarUrl);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateUserExtendedData(String handle, String userExtendedData, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateUserExtendedData(
            userExtendedData,
            new ZIMUserExtendedDataUpdatedCallback() {
                @Override
                public void onUserExtendedDataUpdated(String extendedData, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("extendedData", extendedData);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryConversation(String handle, String conversationID, int conversationType, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryConversation(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMConversationQueriedCallback() {
                @Override
                public void onConversationQueried(ZIMConversation conversation, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("conversation", RNZIMConverter.convertConversationFromJavaToJs(conversation));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryConversationList(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationQueryConfig configObj = new ZIMConversationQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextConversation =
                config.hasKey("nextConversation")
                    ? RNZIMConverter.convertConversationFromJsToJava(config.getMap("nextConversation"))
                    : null;
        }

        zim.queryConversationList(
            configObj,
            new ZIMConversationListQueriedCallback() {
                @Override
                public void onConversationListQueried(ArrayList<ZIMConversation> conversationList, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        WritableArray convInfoArray = Arguments.createArray();
                        for (ZIMConversation conversation : conversationList) {
                            convInfoArray.pushMap(RNZIMConverter.convertConversationFromJavaToJs(conversation));
                        }

                        returnMap.putArray("conversationList", convInfoArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryConversationPinnedList(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationQueryConfig configObj = new ZIMConversationQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextConversation =
                config.hasKey("nextConversation")
                    ? RNZIMConverter.convertConversationFromJsToJava(config.getMap("nextConversation"))
                    : null;
        }

        zim.queryConversationPinnedList(
            configObj,
            new ZIMConversationPinnedListQueriedCallback() {
                @Override
                public void onConversationPinnedListQueried(
                    ArrayList<ZIMConversation> conversationList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        WritableArray convInfoArray = Arguments.createArray();
                        for (ZIMConversation conversation : conversationList) {
                            convInfoArray.pushMap(RNZIMConverter.convertConversationFromJavaToJs(conversation));
                        }

                        returnMap.putArray("conversationList", convInfoArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void deleteConversation(
        String handle,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationDeleteConfig configObj = new ZIMConversationDeleteConfig();
        if (config != null) {
            configObj.isAlsoDeleteServerConversation =
                config.hasKey("isAlsoDeleteServerConversation")
                    ? config.getBoolean("isAlsoDeleteServerConversation")
                    : true;
        }

        zim.deleteConversation(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMConversationDeletedCallback() {
                @Override
                public void onConversationDeleted(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setConversationNotificationStatus(
        String handle,
        int status,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.setConversationNotificationStatus(
            ZIMConversationNotificationStatus.getZIMConversationNotificationStatus(status),
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMConversationNotificationStatusSetCallback() {
                @Override
                public void onConversationNotificationStatusSet(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateConversationPinnedState(
        String handle,
        boolean isPinned,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateConversationPinnedState(
            isPinned,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMConversationPinnedStateUpdatedCallback() {
                @Override
                public void onConversationPinnedStateUpdated(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void clearConversationUnreadMessageCount(
        String handle,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.clearConversationUnreadMessageCount(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMConversationUnreadMessageCountClearedCallback() {
                @Override
                public void onConversationUnreadMessageCountCleared(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void sendMessage(
        String handle,
        ReadableMap message,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final String messageAttachedHandle,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationType type = ZIMConversationType.getZIMConversationType(conversationType);
        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        ZIMMessageSendConfig configObj = new ZIMMessageSendConfig();
        if (config != null) {
            configObj.priority =
                config.hasKey("priority")
                    ? ZIMMessagePriority.getZIMMessagePriority(config.getInt("priority"))
                    : ZIMMessagePriority.LOW;
            configObj.hasReceipt = config.hasKey("hasReceipt") ? config.getBoolean("hasReceipt") : false;
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.sendMessage(
            messageObj,
            conversationID,
            type,
            configObj,
            new ZIMMessageSentCallback() {
                @Override
                public void onMessageAttached(ZIMMessage message) {
                    WritableMap paramsMap = Arguments.createMap();
                    paramsMap.putString("handle", messageAttachedHandle);

                    WritableArray dataArray = Arguments.createArray();
                    dataArray.pushMap(RNZIMConverter.convertMessageFromJavaToJs(message));
                    paramsMap.putArray("data", dataArray);

                    sendAPIEvent("messageAttached", paramsMap);
                }

                @Override
                public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap messageMap = RNZIMConverter.convertMessageFromJavaToJs(message);
                        returnMap.putMap("message", messageMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void sendMediaMessage(
        String handle,
        ReadableMap message,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final String progressHandle,
        final String messageAttachedHandle,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationType type = ZIMConversationType.getZIMConversationType(conversationType);
        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        ZIMMessageSendConfig configObj = new ZIMMessageSendConfig();
        if (config != null) {
            configObj.priority =
                config.hasKey("priority")
                    ? ZIMMessagePriority.getZIMMessagePriority(config.getInt("priority"))
                    : ZIMMessagePriority.LOW;
            configObj.hasReceipt = config.hasKey("hasReceipt") ? config.getBoolean("hasReceipt") : false;
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.sendMediaMessage(
            (ZIMMediaMessage) messageObj,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMMediaMessageSentCallback() {
                @Override
                public void onMessageSent(ZIMMediaMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap messageMap = RNZIMConverter.convertMessageFromJavaToJs(message);
                        returnMap.putMap("message", messageMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }

                @Override
                public void onMessageAttached(ZIMMediaMessage message) {
                    WritableMap paramsMap = Arguments.createMap();
                    paramsMap.putString("handle", messageAttachedHandle);

                    WritableArray dataArray = Arguments.createArray();
                    dataArray.pushMap(RNZIMConverter.convertMessageFromJavaToJs(message));
                    paramsMap.putArray("data", dataArray);

                    sendAPIEvent("messageAttached", paramsMap);
                }

                @Override
                public void onMediaUploadingProgress(
                    ZIMMediaMessage message,
                    long currentFileSize,
                    long totalFileSize
                ) {
                    WritableMap paramsMap = Arguments.createMap();
                    paramsMap.putString("handle", progressHandle);

                    WritableArray dataArray = Arguments.createArray();
                    dataArray.pushMap(RNZIMConverter.convertMessageFromJavaToJs(message));
                    dataArray.pushDouble(currentFileSize);
                    dataArray.pushDouble(totalFileSize);
                    paramsMap.putArray("data", dataArray);

                    sendAPIEvent("mediaUploadingProgress", paramsMap);
                }
            }
        );
    }

    @ReactMethod
    public void deleteMessages(
        String handle,
        ReadableArray messageList,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<ZIMMessage> zimMessageArrayList = new ArrayList<>();
        for (Object messageObj : messageList.toArrayList()) {
            ZIMMessage message = RNZIMConverter.convertMessageFromJsToJava((HashMap<String, Object>) messageObj);
            zimMessageArrayList.add(message);
        }

        ZIMMessageDeleteConfig configObj = new ZIMMessageDeleteConfig();
        if (config != null) {
            configObj.isAlsoDeleteServerMessage =
                config.hasKey("isAlsoDeleteServerMessage") ? config.getBoolean("isAlsoDeleteServerMessage") : true;
        }

        zim.deleteMessages(
            zimMessageArrayList,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMMessageDeletedCallback() {
                @Override
                public void onMessageDeleted(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void deleteAllMessage(
        String handle,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessageDeleteConfig configObj = new ZIMMessageDeleteConfig();
        if (config != null) {
            configObj.isAlsoDeleteServerMessage =
                config.hasKey("isAlsoDeleteServerMessage") ? config.getBoolean("isAlsoDeleteServerMessage") : true;
        }

        zim.deleteAllMessage(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMMessageDeletedCallback() {
                @Override
                public void onMessageDeleted(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryHistoryMessage(
        String handle,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessageQueryConfig configObj = new ZIMMessageQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.reverse = config.hasKey("reverse") ? config.getBoolean("reverse") : false;
            configObj.nextMessage =
                config.hasKey("nextMessage")
                    ? RNZIMConverter.convertMessageFromJsToJava(config.getMap("nextMessage"))
                    : null;
        }

        zim.queryHistoryMessage(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMMessageQueriedCallback() {
                @Override
                public void onMessageQueried(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ArrayList<ZIMMessage> messageList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());
                        returnMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void downloadMediaFile(
        String handle,
        ReadableMap message,
        int fileType,
        final String progressHandle,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        zim.downloadMediaFile(
            (ZIMMediaMessage) messageObj,
            ZIMMediaFileType.getZIMMediaFileType(fileType),
            new ZIMMediaDownloadedCallback() {
                @Override
                public void onMediaDownloaded(ZIMMediaMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap messageMap = RNZIMConverter.convertMessageFromJavaToJs(message);
                        returnMap.putMap("message", messageMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }

                @Override
                public void onMediaDownloadingProgress(
                    ZIMMediaMessage message,
                    long currentFileSize,
                    long totalFileSize
                ) {
                    WritableMap paramsMap = Arguments.createMap();
                    paramsMap.putString("handle", progressHandle);

                    WritableArray dataArray = Arguments.createArray();
                    dataArray.pushMap(RNZIMConverter.convertMessageFromJavaToJs(message));
                    dataArray.pushDouble(currentFileSize);
                    dataArray.pushDouble(totalFileSize);
                    paramsMap.putArray("data", dataArray);

                    sendAPIEvent("mediaDownloadingProgress", paramsMap);
                }
            }
        );
    }

    @ReactMethod
    public void insertMessageToLocalDB(
        String handle,
        ReadableMap message,
        String conversationID,
        int conversationType,
        String senderUserID,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        zim.insertMessageToLocalDB(
            messageObj,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            senderUserID,
            new ZIMMessageInsertedCallback() {
                @Override
                public void onMessageInserted(ZIMMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap messageMap = RNZIMConverter.convertMessageFromJavaToJs(message);
                        returnMap.putMap("message", messageMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateMessageLocalExtendedData(
        String handle,
        String localExtendedData,
        ReadableMap message,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        zim.updateMessageLocalExtendedData(
            localExtendedData,
            messageObj,
            new ZIMMessageLocalExtendedDataUpdatedCallback() {
                @Override
                public void onMessageExtendedDataUpdated(ZIMMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap messageMap = RNZIMConverter.convertMessageFromJavaToJs(message);
                        returnMap.putMap("message", messageMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void sendConversationMessageReceiptRead(
        String handle,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.sendConversationMessageReceiptRead(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMConversationMessageReceiptReadSentCallback() {
                @Override
                public void onConversationMessageReceiptReadSent(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void sendMessageReceiptsRead(
        String handle,
        ReadableArray messageList,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<ZIMMessage> zimMessageArrayList = new ArrayList<>();
        for (Object messageObj : messageList.toArrayList()) {
            ZIMMessage message = RNZIMConverter.convertMessageFromJsToJava((HashMap<String, Object>) messageObj);
            zimMessageArrayList.add(message);
        }

        zim.sendMessageReceiptsRead(
            zimMessageArrayList,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMMessageReceiptsReadSentCallback() {
                @Override
                public void onMessageReceiptsReadSent(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ArrayList<Long> errorMessageIDs,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        WritableArray errorMessageIDsArray = Arguments.createArray();
                        for (long key : errorMessageIDs) {
                            errorMessageIDsArray.pushString(String.valueOf(key));
                        }
                        returnMap.putArray("errorMessageIDs", errorMessageIDsArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryMessageReceiptsInfo(
        String handle,
        ReadableArray messageList,
        String conversationID,
        int conversationType,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<ZIMMessage> zimMessageArrayList = new ArrayList<>();
        for (Object messageObj : messageList.toArrayList()) {
            ZIMMessage message = RNZIMConverter.convertMessageFromJsToJava((HashMap<String, Object>) messageObj);
            zimMessageArrayList.add(message);
        }

        zim.queryMessageReceiptsInfo(
            zimMessageArrayList,
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            new ZIMMessageReceiptsInfoQueriedCallback() {
                @Override
                public void onMessageReceiptsInfoQueried(
                    ArrayList<ZIMMessageReceiptInfo> infos,
                    ArrayList<Long> errorMessageIDs,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putArray("infos", RNZIMConverter.convertMessageReceiptInfoListFromJavaToJs(infos));

                        WritableArray errorMessageIDsArray = Arguments.createArray();
                        for (long key : errorMessageIDs) {
                            errorMessageIDsArray.pushString(String.valueOf(key));
                        }
                        returnMap.putArray("errorMessageIDs", errorMessageIDsArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupMessageReceiptMemberList(
        String handle,
        ReadableMap message,
        String groupID,
        ReadableMap config,
        boolean read,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        ZIMGroupMessageReceiptMemberQueryConfig configObj = new ZIMGroupMessageReceiptMemberQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getInt("nextFlag") : 0;
        }

        ZIMGroupMessageReceiptMemberListQueriedCallback callback =
            new ZIMGroupMessageReceiptMemberListQueriedCallback() {
                @Override
                public void onGroupMessageReceiptMemberListQueried(
                    String groupID,
                    ArrayList<ZIMGroupMemberInfo> userList,
                    int nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putInt("nextFlag", nextFlag);
                        returnMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            };

        if (read) {
            zim.queryGroupMessageReceiptReadMemberList(messageObj, groupID, configObj, callback);
        } else {
            zim.queryGroupMessageReceiptUnreadMemberList(messageObj, groupID, configObj, callback);
        }
    }

    @ReactMethod
    public void revokeMessage(String handle, ReadableMap message, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        ZIMMessageRevokeConfig configObj = new ZIMMessageRevokeConfig();
        if (config != null) {
            configObj.revokeExtendedData =
                config.hasKey("revokeExtendedData") ? config.getString("revokeExtendedData") : "";
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.revokeMessage(
            messageObj,
            configObj,
            new ZIMMessageRevokedCallback() {
                @Override
                public void onMessageRevoked(ZIMMessage message, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("message", RNZIMConverter.convertMessageFromJavaToJs(message));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void addMessageReaction(String handle, String reactionType, ReadableMap message, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);

        zim.addMessageReaction(
            reactionType,
            messageObj,
            new ZIMMessageReactionAddedCallback() {
                @Override
                public void onMessageReactionAdded(ZIMMessageReaction reaction, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("reaction", RNZIMConverter.convertMessageReactionFromJavaToJs(reaction));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void deleteMessageReaction(String handle, String reactionType, ReadableMap message, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);

        zim.deleteMessageReaction(
            reactionType,
            messageObj,
            new ZIMMessageReactionDeletedCallback() {
                @Override
                public void onMessageReactionDeleted(ZIMMessageReaction reaction, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("reaction", RNZIMConverter.convertMessageReactionFromJavaToJs(reaction));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryMessageReactionUserList(
        String handle,
        ReadableMap message,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessage messageObj = RNZIMConverter.convertMessageFromJsToJava(message);
        ZIMMessageReactionUserQueryConfig configObj = new ZIMMessageReactionUserQueryConfig();
        if (config != null) {
            configObj.reactionType = config.hasKey("reactionType") ? config.getString("reactionType") : "";
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag =
                config.hasKey("nextFlag") ? Double.valueOf(config.getDouble("nextFlag")).longValue() : 0;
        }

        zim.queryMessageReactionUserList(
            messageObj,
            configObj,
            new ZIMMessageReactionUserListQueriedCallback() {
                @Override
                public void onMessageReactionUserListQueried(
                    ZIMMessage message,
                    ArrayList<ZIMMessageReactionUserInfo> userList,
                    String reactionType,
                    long nextFlag,
                    int totalCount,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("reactionType", reactionType);
                        returnMap.putDouble("nextFlag", nextFlag);
                        returnMap.putInt("totalCount", totalCount);

                        WritableArray userArray = Arguments.createArray();
                        for (ZIMMessageReactionUserInfo user : userList) {
                            WritableMap userMap = Arguments.createMap();
                            userMap.putString("userID", user.userID);
                            userArray.pushMap(userMap);
                        }
                        returnMap.putArray("userList", userArray);

                        returnMap.putMap("message", RNZIMConverter.convertMessageFromJavaToJs(message));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void createRoom(String handle, ReadableMap roomInfo, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMRoomInfo roomInfoObj = new ZIMRoomInfo();
        roomInfoObj.roomID = roomInfo.getString("roomID");
        roomInfoObj.roomName = roomInfo.hasKey("roomName") ? roomInfo.getString("roomName") : "";

        if (config != null) {
            ZIMRoomAdvancedConfig configObj = new ZIMRoomAdvancedConfig();
            configObj.roomDestroyDelayTime =
                config.hasKey("roomDestroyDelayTime") ? config.getInt("roomDestroyDelayTime") : 0;

            if (config.hasKey("roomAttributes")) {
                HashMap<String, String> roomAttributes = new HashMap<>();
                HashMap<String, Object> roomAttrMap = config.getMap("roomAttributes").toHashMap();
                for (String key : roomAttrMap.keySet()) {
                    roomAttributes.put(key, (String) roomAttrMap.get(key));
                }

                configObj.roomAttributes = roomAttributes;
            }

            zim.createRoom(
                roomInfoObj,
                configObj,
                new ZIMRoomCreatedCallback() {
                    @Override
                    public void onRoomCreated(ZIMRoomFullInfo roomInfo, ZIMError errorInfo) {
                        if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                            WritableMap returnMap = Arguments.createMap();
                            returnMap.putMap("roomInfo", RNZIMConverter.convertFullRoomInfoFromJavaToJs(roomInfo));
                            promise.resolve(returnMap);
                        } else {
                            promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                        }
                    }
                }
            );
        } else {
            zim.createRoom(
                roomInfoObj,
                new ZIMRoomCreatedCallback() {
                    @Override
                    public void onRoomCreated(ZIMRoomFullInfo roomInfo, ZIMError errorInfo) {
                        if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                            WritableMap returnMap = Arguments.createMap();
                            returnMap.putMap("roomInfo", RNZIMConverter.convertFullRoomInfoFromJavaToJs(roomInfo));
                            promise.resolve(returnMap);
                        } else {
                            promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                        }
                    }
                }
            );
        }
    }

    @ReactMethod
    public void enterRoom(String handle, ReadableMap roomInfo, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMRoomInfo roomInfoObj = new ZIMRoomInfo();
        roomInfoObj.roomID = roomInfo.getString("roomID");
        roomInfoObj.roomName = roomInfo.hasKey("roomName") ? roomInfo.getString("roomName") : "";

        ZIMRoomAdvancedConfig configObj = null;
        if (config != null) {
            configObj = new ZIMRoomAdvancedConfig();
            configObj.roomDestroyDelayTime =
                config.hasKey("roomDestroyDelayTime") ? config.getInt("roomDestroyDelayTime") : 0;

            if (config.hasKey("roomAttributes")) {
                HashMap<String, String> roomAttributes = new HashMap<>();
                HashMap<String, Object> roomAttrMap = config.getMap("roomAttributes").toHashMap();
                for (String key : roomAttrMap.keySet()) {
                    roomAttributes.put(key, (String) roomAttrMap.get(key));
                }

                configObj.roomAttributes = roomAttributes;
            }
        }

        zim.enterRoom(
            roomInfoObj,
            configObj,
            new ZIMRoomEnteredCallback() {
                @Override
                public void onRoomEntered(ZIMRoomFullInfo roomInfo, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("roomInfo", RNZIMConverter.convertFullRoomInfoFromJavaToJs(roomInfo));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void joinRoom(String handle, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.joinRoom(
            roomID,
            new ZIMRoomJoinedCallback() {
                @Override
                public void onRoomJoined(ZIMRoomFullInfo roomInfo, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("roomInfo", RNZIMConverter.convertFullRoomInfoFromJavaToJs(roomInfo));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void leaveRoom(String handle, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.leaveRoom(
            roomID,
            new ZIMRoomLeftCallback() {
                @Override
                public void onRoomLeft(String roomID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomMemberList(String handle, String roomID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMRoomMemberQueryConfig configObj = new ZIMRoomMemberQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getString("nextFlag") : "";
        }

        zim.queryRoomMemberList(
            roomID,
            configObj,
            new ZIMRoomMemberQueriedCallback() {
                @Override
                public void onRoomMemberQueried(
                    String roomID,
                    ArrayList<ZIMUserInfo> memberList,
                    String nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        returnMap.putString("roomID", roomID);
                        returnMap.putString("nextFlag", nextFlag);
                        returnMap.putArray("memberList", RNZIMConverter.convertUserInfoListFromJavaToJs(memberList));

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomMembers(String handle, ReadableArray userIDs, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userIDArray = new ArrayList<>();
        for (Object userID : userIDs.toArrayList()) {
            userIDArray.add((String) userID);
        }

        zim.queryRoomMembers(
            userIDArray,
            roomID,
            new ZIMRoomMembersQueriedCallback() {
                @Override
                public void onRoomMembersQueried(
                    String roomID,
                    ArrayList<ZIMRoomMemberInfo> memberList,
                    ArrayList<ZIMErrorUserInfo> errorUserList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        WritableArray memberArray = Arguments.createArray();
                        for (ZIMRoomMemberInfo userInfo : memberList) {
                            memberArray.pushMap(RNZIMConverter.convertRoomMemberInfoFromJavaToJs(userInfo));
                        }

                        returnMap.putString("roomID", roomID);
                        returnMap.putArray("memberList", memberArray);
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                        );

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomOnlineMemberCount(String handle, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryRoomOnlineMemberCount(
            roomID,
            new ZIMRoomOnlineMemberCountQueriedCallback() {
                @Override
                public void onRoomOnlineMemberCountQueried(String roomID, int count, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);
                        returnMap.putInt("count", count);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomAllAttributes(String handle, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryRoomAllAttributes(
            roomID,
            new ZIMRoomAttributesQueriedCallback() {
                @Override
                public void onRoomAttributesQueried(
                    String roomID,
                    HashMap<String, String> roomAttributes,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        WritableMap roomAttrMap = Arguments.createMap();
                        for (String key : roomAttributes.keySet()) {
                            roomAttrMap.putString(key, roomAttributes.get(key));
                        }
                        returnMap.putString("roomID", roomID);
                        returnMap.putMap("roomAttributes", roomAttrMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setRoomAttributes(
        String handle,
        ReadableMap roomAttributes,
        String roomID,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        HashMap<String, String> roomAttrsMap = new HashMap<>();
        for (String key : roomAttributes.toHashMap().keySet()) {
            roomAttrsMap.put(key, roomAttributes.getString(key));
        }

        ZIMRoomAttributesSetConfig configObj = new ZIMRoomAttributesSetConfig();
        if (config != null) {
            configObj.isUpdateOwner = config.hasKey("isUpdateOwner") ? config.getBoolean("isUpdateOwner") : false;
            configObj.isDeleteAfterOwnerLeft =
                config.hasKey("isDeleteAfterOwnerLeft") ? config.getBoolean("isDeleteAfterOwnerLeft") : false;
            configObj.isForce = config.hasKey("isForce") ? config.getBoolean("isForce") : false;
        }

        zim.setRoomAttributes(
            roomAttrsMap,
            roomID,
            configObj,
            new ZIMRoomAttributesOperatedCallback() {
                @Override
                public void onRoomAttributesOperated(String roomID, ArrayList<String> errorKeys, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);
                        WritableArray errorKeysArray = Arguments.createArray();
                        for (String key : errorKeys) {
                            errorKeysArray.pushString(key);
                        }
                        returnMap.putArray("errorKeys", errorKeysArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void deleteRoomAttributes(
        String handle,
        ReadableArray keys,
        String roomID,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> keysArray = new ArrayList<>();
        for (Object key : keys.toArrayList()) {
            keysArray.add((String) key);
        }

        ZIMRoomAttributesDeleteConfig configObj = new ZIMRoomAttributesDeleteConfig();
        if (config != null) {
            configObj.isForce = config.hasKey("isForce") ? config.getBoolean("isForce") : false;
        }

        zim.deleteRoomAttributes(
            keysArray,
            roomID,
            configObj,
            new ZIMRoomAttributesOperatedCallback() {
                @Override
                public void onRoomAttributesOperated(String roomID, ArrayList<String> errorKeys, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);
                        WritableArray errorKeysArray = Arguments.createArray();
                        for (String key : errorKeys) {
                            errorKeysArray.pushString(key);
                        }
                        returnMap.putArray("errorKeys", errorKeysArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void beginRoomAttributesBatchOperation(String handle, String roomID, ReadableMap config) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            return;
        }

        ZIMRoomAttributesBatchOperationConfig configObj = new ZIMRoomAttributesBatchOperationConfig();
        if (config != null) {
            configObj.isUpdateOwner = config.hasKey("isUpdateOwner") ? config.getBoolean("isUpdateOwner") : false;
            configObj.isDeleteAfterOwnerLeft =
                config.hasKey("isDeleteAfterOwnerLeft") ? config.getBoolean("isDeleteAfterOwnerLeft") : false;
            configObj.isForce = config.hasKey("isForce") ? config.getBoolean("isForce") : false;
        }

        zim.beginRoomAttributesBatchOperation(roomID, configObj);
    }

    @ReactMethod
    public void endRoomAttributesBatchOperation(String handle, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.endRoomAttributesBatchOperation(
            roomID,
            new ZIMRoomAttributesBatchOperatedCallback() {
                @Override
                public void onRoomAttributesBatchOperated(String roomID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setRoomMembersAttributes(
        String handle,
        ReadableMap attributes,
        ReadableArray userIDs,
        String roomID,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMRoomMemberAttributesSetConfig configObj = new ZIMRoomMemberAttributesSetConfig();
        configObj.isDeleteAfterOwnerLeft =
            config.hasKey("isDeleteAfterOwnerLeft") ? config.getBoolean("isDeleteAfterOwnerLeft") : true;

        HashMap<String, String> roomMembersAttrsMap = new HashMap<>();
        for (String key : attributes.toHashMap().keySet()) {
            roomMembersAttrsMap.put(key, attributes.getString(key));
        }

        ArrayList<String> userIDArray = new ArrayList<>();
        for (Object userID : userIDs.toArrayList()) {
            userIDArray.add((String) userID);
        }

        zim.setRoomMembersAttributes(
            roomMembersAttrsMap,
            userIDArray,
            roomID,
            configObj,
            new ZIMRoomMembersAttributesOperatedCallback() {
                @Override
                public void onRoomMembersAttributesOperated(
                    String roomID,
                    ArrayList<ZIMRoomMemberAttributesOperatedInfo> infos,
                    ArrayList<String> errorUserList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);

                        ReadableArray infoArray =
                            RNZIMConverter.convertRoomMemberAttributesOperatedInfoListFromJavaToJs(infos);
                        returnMap.putArray("infos", infoArray);

                        WritableArray errorUserArray = Arguments.createArray();
                        for (String key : errorUserList) {
                            errorUserArray.pushString(key);
                        }

                        returnMap.putArray("errorUserList", errorUserArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomMembersAttributes(String handle, ReadableArray userIDs, String roomID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userIDArray = new ArrayList<>();
        for (Object userID : userIDs.toArrayList()) {
            userIDArray.add((String) userID);
        }

        zim.queryRoomMembersAttributes(
            userIDArray,
            roomID,
            new ZIMRoomMembersAttributesQueriedCallback() {
                @Override
                public void onRoomMembersAttributesQueried(
                    String roomID,
                    ArrayList<ZIMRoomMemberAttributesInfo> infos,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);

                        ReadableArray infoArray = RNZIMConverter.convertRoomMemberAttributesInfoListFromJavaToJs(infos);
                        returnMap.putArray("infos", infoArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryRoomMemberAttributesList(String handle, String roomID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMRoomMemberAttributesQueryConfig configObj = new ZIMRoomMemberAttributesQueryConfig();
        configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
        configObj.nextFlag = config.hasKey("nextFlag") ? config.getString("nextFlag") : "";

        zim.queryRoomMemberAttributesList(
            roomID,
            configObj,
            new ZIMRoomMemberAttributesListQueriedCallback() {
                @Override
                public void onRoomMemberAttributesListQueried(
                    String roomID,
                    ArrayList<ZIMRoomMemberAttributesInfo> infos,
                    String nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("roomID", roomID);

                        ReadableArray infoArray = RNZIMConverter.convertRoomMemberAttributesInfoListFromJavaToJs(infos);
                        returnMap.putArray("infos", infoArray);

                        returnMap.putString("nextFlag", nextFlag);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void createGroup(
        String handle,
        ReadableMap groupInfo,
        ReadableArray userIDs,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMGroupInfo groupInfoObj = new ZIMGroupInfo();
        groupInfoObj.groupID = groupInfo.getString("groupID");
        groupInfoObj.groupName = groupInfo.hasKey("groupName") ? groupInfo.getString("groupName") : "";
        groupInfoObj.groupAvatarUrl = groupInfo.hasKey("groupAvatarUrl") ? groupInfo.getString("groupAvatarUrl") : "";

        ArrayList<String> userIDArray = new ArrayList<>();
        for (Object userID : userIDs.toArrayList()) {
            userIDArray.add((String) userID);
        }

        if (config != null) {
            ZIMGroupAdvancedConfig configObj = new ZIMGroupAdvancedConfig();
            configObj.groupNotice = config.hasKey("groupNotice") ? config.getString("groupNotice") : "";

            if (config.hasKey("groupAttributes")) {
                HashMap<String, String> groupAttributes = new HashMap<>();
                HashMap<String, Object> groupAttrMap = config.getMap("groupAttributes").toHashMap();
                for (String key : groupAttrMap.keySet()) {
                    groupAttributes.put(key, (String) groupAttrMap.get(key));
                }

                configObj.groupAttributes = groupAttributes;
            }

            zim.createGroup(
                groupInfoObj,
                userIDArray,
                configObj,
                new ZIMGroupCreatedCallback() {
                    @Override
                    public void onGroupCreated(
                        ZIMGroupFullInfo groupInfo,
                        ArrayList<ZIMGroupMemberInfo> userList,
                        ArrayList<ZIMErrorUserInfo> errorUserList,
                        ZIMError errorInfo
                    ) {
                        if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                            WritableMap returnMap = Arguments.createMap();
                            returnMap.putMap("groupInfo", RNZIMConverter.convertFullGroupInfoFromJavaToJs(groupInfo));
                            returnMap.putArray(
                                "userList",
                                RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList)
                            );
                            returnMap.putArray(
                                "errorUserList",
                                RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                            );
                            promise.resolve(returnMap);
                        } else {
                            promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                        }
                    }
                }
            );
        } else {
            zim.createGroup(
                groupInfoObj,
                userIDArray,
                new ZIMGroupCreatedCallback() {
                    @Override
                    public void onGroupCreated(
                        ZIMGroupFullInfo groupInfo,
                        ArrayList<ZIMGroupMemberInfo> userList,
                        ArrayList<ZIMErrorUserInfo> errorUserList,
                        ZIMError errorInfo
                    ) {
                        if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                            WritableMap returnMap = Arguments.createMap();
                            returnMap.putMap("groupInfo", RNZIMConverter.convertFullGroupInfoFromJavaToJs(groupInfo));
                            returnMap.putArray(
                                "userList",
                                RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList)
                            );
                            returnMap.putArray(
                                "errorUserList",
                                RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                            );
                            promise.resolve(returnMap);
                        } else {
                            promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                        }
                    }
                }
            );
        }
    }

    @ReactMethod
    public void joinGroup(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.joinGroup(
            groupID,
            new ZIMGroupJoinedCallback() {
                @Override
                public void onGroupJoined(ZIMGroupFullInfo groupInfo, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("groupInfo", RNZIMConverter.convertFullGroupInfoFromJavaToJs(groupInfo));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void leaveGroup(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.leaveGroup(
            groupID,
            new ZIMGroupLeftCallback() {
                @Override
                public void onGroupLeft(String groupID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void dismissGroup(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.dismissGroup(
            groupID,
            new ZIMGroupDismissedCallback() {
                @Override
                public void onGroupDismissed(String groupID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupList(String handle, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryGroupList(
            new ZIMGroupListQueriedCallback() {
                @Override
                public void onGroupListQueried(ArrayList<ZIMGroup> groupList, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putArray("groupList", RNZIMConverter.convertGroupListFromJavaToJs(groupList));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateGroupNotice(String handle, String groupNotice, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateGroupNotice(
            groupNotice,
            groupID,
            new ZIMGroupNoticeUpdatedCallback() {
                @Override
                public void onGroupNoticeUpdated(String groupID, String groupNotice, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("groupNotice", groupNotice);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateGroupName(String handle, String groupName, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateGroupName(
            groupName,
            groupID,
            new ZIMGroupNameUpdatedCallback() {
                @Override
                public void onGroupNameUpdated(String groupID, String groupName, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("groupName", groupName);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void updateGroupAvatarUrl(String handle, String groupAvatarUrl, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.updateGroupAvatarUrl(
            groupAvatarUrl,
            groupID,
            new ZIMGroupAvatarUrlUpdatedCallback() {
                @Override
                public void onGroupAvatarUrlUpdated(String groupID, String groupAvatarUrl, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("groupAvatarUrl", groupAvatarUrl);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupInfo(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryGroupInfo(
            groupID,
            new ZIMGroupInfoQueriedCallback() {
                @Override
                public void onGroupInfoQueried(ZIMGroupFullInfo groupInfo, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putMap("groupInfo", RNZIMConverter.convertFullGroupInfoFromJavaToJs(groupInfo));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupMemberCount(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryGroupMemberCount(
            groupID,
            new ZIMGroupMemberCountQueriedCallback() {
                @Override
                public void onGroupMemberCountQueried(String groupID, int count, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putInt("count", count);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setGroupAttributes(String handle, ReadableMap groupAttributes, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        HashMap<String, String> groupAttrMap = new HashMap<>();
        for (String key : groupAttributes.toHashMap().keySet()) {
            groupAttrMap.put(key, groupAttributes.getString(key));
        }

        zim.setGroupAttributes(
            groupAttrMap,
            groupID,
            new ZIMGroupAttributesOperatedCallback() {
                @Override
                public void onGroupAttributesOperated(String groupID, ArrayList<String> errorKeys, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        WritableArray errorKeysArray = Arguments.createArray();
                        for (String key : errorKeys) {
                            errorKeysArray.pushString(key);
                        }
                        returnMap.putArray("errorKeys", errorKeysArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void deleteGroupAttributes(String handle, ReadableArray keys, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> keyArray = new ArrayList<>();
        for (Object key : keys.toArrayList()) {
            keyArray.add((String) key);
        }

        zim.deleteGroupAttributes(
            keyArray,
            groupID,
            new ZIMGroupAttributesOperatedCallback() {
                @Override
                public void onGroupAttributesOperated(String groupID, ArrayList<String> errorKeys, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        WritableArray errorKeysArray = Arguments.createArray();
                        for (String key : errorKeys) {
                            errorKeysArray.pushString(key);
                        }
                        returnMap.putArray("errorKeys", errorKeysArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupAttributes(String handle, ReadableArray keys, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> keyArray = new ArrayList<>();
        for (Object key : keys.toArrayList()) {
            keyArray.add((String) key);
        }

        zim.queryGroupAttributes(
            keyArray,
            groupID,
            new ZIMGroupAttributesQueriedCallback() {
                @Override
                public void onGroupAttributesQueried(
                    String groupID,
                    HashMap<String, String> groupAttributes,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        WritableMap groupAttrMap = Arguments.createMap();
                        for (String key : groupAttributes.keySet()) {
                            groupAttrMap.putString(key, groupAttributes.get(key));
                        }
                        returnMap.putMap("groupAttributes", groupAttrMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupAllAttributes(String handle, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryGroupAllAttributes(
            groupID,
            new ZIMGroupAttributesQueriedCallback() {
                @Override
                public void onGroupAttributesQueried(
                    String groupID,
                    HashMap<String, String> groupAttributes,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        WritableMap groupAttrMap = Arguments.createMap();
                        for (String key : groupAttributes.keySet()) {
                            groupAttrMap.putString(key, groupAttributes.get(key));
                        }
                        returnMap.putMap("groupAttributes", groupAttrMap);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setGroupMemberNickname(
        String handle,
        String nickname,
        String forUserID,
        String groupID,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.setGroupMemberNickname(
            nickname,
            forUserID,
            groupID,
            new ZIMGroupMemberNicknameUpdatedCallback() {
                @Override
                public void onGroupMemberNicknameUpdated(
                    String groupID,
                    String forUserID,
                    String nickname,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("forUserID", forUserID);
                        returnMap.putString("nickname", nickname);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void setGroupMemberRole(String handle, int role, String forUserID, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.setGroupMemberRole(
            role,
            forUserID,
            groupID,
            new ZIMGroupMemberRoleUpdatedCallback() {
                @Override
                public void onGroupMemberRoleUpdated(String groupID, String forUserID, int role, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("forUserID", forUserID);
                        returnMap.putInt("role", role);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void transferGroupOwner(String handle, String toUserID, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.transferGroupOwner(
            toUserID,
            groupID,
            new ZIMGroupOwnerTransferredCallback() {
                @Override
                public void onGroupOwnerTransferred(String groupID, String toUserID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putString("toUserID", toUserID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupMemberInfo(String handle, String userID, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        zim.queryGroupMemberInfo(
            userID,
            groupID,
            new ZIMGroupMemberInfoQueriedCallback() {
                @Override
                public void onGroupMemberInfoQueried(String groupID, ZIMGroupMemberInfo userInfo, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putMap("userInfo", RNZIMConverter.convertGroupMemberInfoFromJavaToJs(userInfo));
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void inviteUsersIntoGroup(String handle, ReadableArray userIDs, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userArray = new ArrayList<>();
        for (Object key : userIDs.toArrayList()) {
            userArray.add((String) key);
        }

        zim.inviteUsersIntoGroup(
            userArray,
            groupID,
            new ZIMGroupUsersInvitedCallback() {
                @Override
                public void onGroupUsersInvited(
                    String groupID,
                    ArrayList<ZIMGroupMemberInfo> userList,
                    ArrayList<ZIMErrorUserInfo> errorUserList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                        );
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void kickGroupMembers(String handle, ReadableArray userIDs, String groupID, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userArray = new ArrayList<>();
        for (Object key : userIDs.toArrayList()) {
            userArray.add((String) key);
        }

        zim.kickGroupMembers(
            userArray,
            groupID,
            new ZIMGroupMemberKickedCallback() {
                @Override
                public void onGroupMemberKicked(
                    String groupID,
                    ArrayList<String> kickedUserIDList,
                    ArrayList<ZIMErrorUserInfo> errorUserList,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        WritableArray userIDArray = Arguments.createArray();
                        for (String userID : kickedUserIDList) {
                            userIDArray.pushString(userID);
                        }
                        returnMap.putArray("kickedUserIDs", userIDArray);
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(errorUserList)
                        );
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryGroupMemberList(String handle, String groupID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMGroupMemberQueryConfig configObj = new ZIMGroupMemberQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getInt("nextFlag") : 0;
        }

        zim.queryGroupMemberList(
            groupID,
            configObj,
            new ZIMGroupMemberListQueriedCallback() {
                @Override
                public void onGroupMemberListQueried(
                    String groupID,
                    ArrayList<ZIMGroupMemberInfo> userList,
                    int nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));
                        returnMap.putInt("nextFlag", nextFlag);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callInvite(String handle, ReadableArray invitees, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userArray = new ArrayList<>();
        for (Object key : invitees.toArrayList()) {
            userArray.add((String) key);
        }

        ZIMCallInviteConfig configObj = new ZIMCallInviteConfig();
        if (config != null) {
            configObj.mode =
                ZIMCallInvitationMode.getZIMCallInvitationMode(config.hasKey("mode") ? config.getInt("mode") : 0);
            configObj.timeout = config.hasKey("timeout") ? config.getInt("timeout") : 90;
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.callInvite(
            userArray,
            configObj,
            new ZIMCallInvitationSentCallback() {
                @Override
                public void onCallInvitationSent(String callID, ZIMCallInvitationSentInfo info, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        returnMap.putInt("timeout", info.timeout);
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(info.errorUserList)
                        );
                        returnMap.putArray(
                            "errorInvitees",
                            RNZIMConverter.convertCallUserListFromJavaToJs(info.errorInvitees)
                        );
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callCancel(
        String handle,
        ReadableArray invitees,
        String callID,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userArray = new ArrayList<>();
        for (Object key : invitees.toArrayList()) {
            userArray.add((String) key);
        }

        ZIMCallCancelConfig configObj = new ZIMCallCancelConfig();
        if (config != null) {
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.callCancel(
            userArray,
            callID,
            configObj,
            new ZIMCallCancelSentCallback() {
                @Override
                public void onCallCancelSent(String callID, ArrayList<String> errorInvitees, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        WritableArray errorUserArray = Arguments.createArray();
                        for (String invitee : errorInvitees) {
                            errorUserArray.pushString(invitee);
                        }
                        returnMap.putArray("errorInvitees", errorUserArray);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callAccept(String handle, String callID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMCallAcceptConfig configObj = new ZIMCallAcceptConfig();
        if (config != null) {
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
        }

        zim.callAccept(
            callID,
            configObj,
            new ZIMCallAcceptanceSentCallback() {
                @Override
                public void onCallAcceptanceSent(String callID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callReject(String handle, String callID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMCallRejectConfig configObj = new ZIMCallRejectConfig();
        if (config != null) {
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
        }

        zim.callReject(
            callID,
            configObj,
            new ZIMCallRejectionSentCallback() {
                @Override
                public void onCallRejectionSent(String callID, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callQuit(String handle, String callID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMCallQuitConfig configObj = new ZIMCallQuitConfig();
        if (config != null) {
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.callQuit(
            callID,
            configObj,
            new ZIMCallQuitSentCallback() {
                @Override
                public void onCallQuitSent(String callID, ZIMCallQuitSentInfo info, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        returnMap.putDouble("createTime", info.createTime);
                        returnMap.putDouble("acceptTime", info.acceptTime);
                        returnMap.putDouble("quitTime", info.quitTime);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callEnd(String handle, String callID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMCallEndConfig configObj = new ZIMCallEndConfig();
        if (config != null) {
            configObj.extendedData = config.hasKey("extendedData") ? config.getString("extendedData") : "";
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.callEnd(
            callID,
            configObj,
            new ZIMCallEndSentCallback() {
                @Override
                public void onCallEndSent(String callID, ZIMCallEndedSentInfo info, ZIMError errorInfo) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        returnMap.putDouble("createTime", info.createTime);
                        returnMap.putDouble("acceptTime", info.acceptTime);
                        returnMap.putDouble("endTime", info.endTime);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void callingInvite(
        String handle,
        ReadableArray invitees,
        String callID,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ArrayList<String> userArray = new ArrayList<>();
        for (Object key : invitees.toArrayList()) {
            userArray.add((String) key);
        }

        ZIMCallingInviteConfig configObj = new ZIMCallingInviteConfig();
        if (config != null) {
            configObj.pushConfig = RNZIMConverter.convertZIMPushConfig(config);
        }

        zim.callingInvite(
            userArray,
            callID,
            configObj,
            new ZIMCallingInvitationSentCallback() {
                @Override
                public void onCallingInvitationSent(
                    String callID,
                    ZIMCallingInvitationSentInfo info,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("callID", callID);
                        returnMap.putArray(
                            "errorUserList",
                            RNZIMConverter.convertErrorUserInfoListFromJavaToJs(info.errorUserList)
                        );

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void queryCallInvitationList(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMCallInvitationQueryConfig configObj = new ZIMCallInvitationQueryConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag =
                config.hasKey("nextFlag") ? Double.valueOf(config.getDouble("nextFlag")).longValue() : 0;
        }

        zim.queryCallInvitationList(
            configObj,
            new ZIMCallInvitationListQueriedCallback() {
                @Override
                public void onCallInvitationListQueried(
                    ArrayList<ZIMCallInfo> callList,
                    long nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putDouble("nextFlag", nextFlag);
                        WritableArray callArray = Arguments.createArray();
                        for (ZIMCallInfo info : callList) {
                            WritableMap infoMap = Arguments.createMap();
                            infoMap.putInt("mode", info.mode.value());
                            infoMap.putInt("state", info.state.value());
                            infoMap.putString("callID", info.callID);
                            infoMap.putString("caller", info.caller);
                            infoMap.putString("extendedData", info.extendedData);
                            infoMap.putDouble("createTime", info.createTime);
                            infoMap.putDouble("endTime", info.endTime);
                            infoMap.putArray(
                                "callUserList",
                                RNZIMConverter.convertCallUserListFromJavaToJs(info.callUserList)
                            );

                            callArray.pushMap(infoMap);
                        }
                        returnMap.putArray("callList", callArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void searchConversations(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMConversationSearchConfig configObj = new ZIMConversationSearchConfig();
        if (config != null) {
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getInt("nextFlag") : 0;
            configObj.totalConversationCount =
                config.hasKey("totalConversationCount") ? config.getInt("totalConversationCount") : 0;
            configObj.conversationMessageCount =
                config.hasKey("conversationMessageCount") ? config.getInt("conversationMessageCount") : 0;
            configObj.startTime =
                config.hasKey("startTime") ? Double.valueOf(config.getDouble("startTime")).longValue() : 0;
            configObj.endTime = config.hasKey("endTime") ? Double.valueOf(config.getDouble("endTime")).longValue() : 0;
            if (config.hasKey("keywords")) {
                ArrayList<String> keywords = new ArrayList<>();
                for (Object key : config.getArray("keywords").toArrayList()) {
                    keywords.add((String) key);
                }
                configObj.keywords = keywords;
            }
            if (config.hasKey("senderUserIDs")) {
                ArrayList<String> senderUserIDs = new ArrayList<>();
                for (Object key : config.getArray("senderUserIDs").toArrayList()) {
                    senderUserIDs.add((String) key);
                }
                configObj.senderUserIDs = senderUserIDs;
            }
            if (config.hasKey("messageTypes")) {
                ArrayList<ZIMMessageType> messageTypes = new ArrayList<>();
                for (Object key : config.getArray("messageTypes").toArrayList()) {
                    messageTypes.add(ZIMMessageType.getZIMMessageType(Double.valueOf((double) key).intValue()));
                }
                configObj.messageTypes = messageTypes;
            }
            if (config.hasKey("subMessageTypes")) {
                ArrayList<Integer> subMessageTypes = new ArrayList<>();
                for (Object key : config.getArray("subMessageTypes").toArrayList()) {
                    subMessageTypes.add(Double.valueOf((double) key).intValue());
                }
                configObj.subMessageTypes = subMessageTypes;
            }
        }

        zim.searchLocalConversations(
            configObj,
            new ZIMConversationsSearchedCallback() {
                @Override
                public void onConversationsSearched(
                    ArrayList<ZIMConversationSearchInfo> conversationSearchInfoList,
                    int nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putInt("nextFlag", nextFlag);

                        WritableArray infoArray = Arguments.createArray();
                        for (ZIMConversationSearchInfo info : conversationSearchInfoList) {
                            WritableMap infoMap = Arguments.createMap();
                            infoMap.putString("conversationID", info.conversationID);
                            infoMap.putInt("conversationType", info.conversationType.value());
                            infoMap.putInt("totalMessageCount", info.totalMessageCount);
                            infoMap.putArray(
                                "messageList",
                                RNZIMConverter.convertMessageListFromJavaToJs(info.messageList)
                            );

                            infoArray.pushMap(infoMap);
                        }
                        returnMap.putArray("conversationSearchInfoList", infoArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void searchGlobalMessages(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessageSearchConfig configObj = new ZIMMessageSearchConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.order = ZIMMessageOrder.getZIMMessageOrder(config.hasKey("order") ? config.getInt("order") : 0);
            configObj.startTime =
                config.hasKey("startTime") ? Double.valueOf(config.getDouble("startTime")).longValue() : 0;
            configObj.endTime = config.hasKey("endTime") ? Double.valueOf(config.getDouble("endTime")).longValue() : 0;
            if (config.hasKey("nextMessage")) {
                configObj.nextMessage = RNZIMConverter.convertMessageFromJsToJava(config.getMap("nextMessage"));
            }
            if (config.hasKey("keywords")) {
                ArrayList<String> keywords = new ArrayList<>();
                for (Object key : config.getArray("keywords").toArrayList()) {
                    keywords.add((String) key);
                }
                configObj.keywords = keywords;
            }
            if (config.hasKey("senderUserIDs")) {
                ArrayList<String> senderUserIDs = new ArrayList<>();
                for (Object key : config.getArray("senderUserIDs").toArrayList()) {
                    senderUserIDs.add((String) key);
                }
                configObj.senderUserIDs = senderUserIDs;
            }
            if (config.hasKey("messageTypes")) {
                ArrayList<ZIMMessageType> messageTypes = new ArrayList<>();
                for (Object key : config.getArray("messageTypes").toArrayList()) {
                    messageTypes.add(ZIMMessageType.getZIMMessageType(Double.valueOf((double) key).intValue()));
                }
                configObj.messageTypes = messageTypes;
            }
            if (config.hasKey("subMessageTypes")) {
                ArrayList<Integer> subMessageTypes = new ArrayList<>();
                for (Object key : config.getArray("subMessageTypes").toArrayList()) {
                    subMessageTypes.add(Double.valueOf((double) key).intValue());
                }
                configObj.subMessageTypes = subMessageTypes;
            }
        }

        zim.searchGlobalLocalMessages(
            configObj,
            new ZIMMessagesGlobalSearchedCallback() {
                @Override
                public void onMessagesGlobalSearched(
                    ArrayList<ZIMMessage> messageList,
                    ZIMMessage nextMessage,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();

                        if (nextMessage != null) {
                            returnMap.putMap("nextMessage", RNZIMConverter.convertMessageFromJavaToJs(nextMessage));
                        } else {
                            returnMap.putNull("nextMessage");
                        }

                        returnMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void searchMessages(
        String handle,
        String conversationID,
        int conversationType,
        ReadableMap config,
        final Promise promise
    ) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMMessageSearchConfig configObj = new ZIMMessageSearchConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.order = ZIMMessageOrder.getZIMMessageOrder(config.hasKey("order") ? config.getInt("order") : 0);
            configObj.startTime =
                config.hasKey("startTime") ? Double.valueOf(config.getDouble("startTime")).longValue() : 0;
            configObj.endTime = config.hasKey("endTime") ? Double.valueOf(config.getDouble("endTime")).longValue() : 0;
            if (config.hasKey("nextMessage")) {
                configObj.nextMessage = RNZIMConverter.convertMessageFromJsToJava(config.getMap("nextMessage"));
            }
            if (config.hasKey("keywords")) {
                ArrayList<String> keywords = new ArrayList<>();
                for (Object key : config.getArray("keywords").toArrayList()) {
                    keywords.add((String) key);
                }
                configObj.keywords = keywords;
            }
            if (config.hasKey("senderUserIDs")) {
                ArrayList<String> senderUserIDs = new ArrayList<>();
                for (Object key : config.getArray("senderUserIDs").toArrayList()) {
                    senderUserIDs.add((String) key);
                }
                configObj.senderUserIDs = senderUserIDs;
            }
            if (config.hasKey("messageTypes")) {
                ArrayList<ZIMMessageType> messageTypes = new ArrayList<>();
                for (Object key : config.getArray("messageTypes").toArrayList()) {
                    messageTypes.add(ZIMMessageType.getZIMMessageType(Double.valueOf((double) key).intValue()));
                }
                configObj.messageTypes = messageTypes;
            }
            if (config.hasKey("subMessageTypes")) {
                ArrayList<Integer> subMessageTypes = new ArrayList<>();
                for (Object key : config.getArray("subMessageTypes").toArrayList()) {
                    subMessageTypes.add(Double.valueOf((double) key).intValue());
                }
                configObj.subMessageTypes = subMessageTypes;
            }
        }

        zim.searchLocalMessages(
            conversationID,
            ZIMConversationType.getZIMConversationType(conversationType),
            configObj,
            new ZIMMessagesSearchedCallback() {
                @Override
                public void onMessagesSearched(
                    String conversationID,
                    ZIMConversationType conversationType,
                    ArrayList<ZIMMessage> messageList,
                    ZIMMessage nextMessage,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("conversationID", conversationID);
                        returnMap.putInt("conversationType", conversationType.value());

                        if (nextMessage != null) {
                            returnMap.putMap("nextMessage", RNZIMConverter.convertMessageFromJavaToJs(nextMessage));
                        } else {
                            returnMap.putNull("nextMessage");
                        }

                        returnMap.putArray("messageList", RNZIMConverter.convertMessageListFromJavaToJs(messageList));

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void searchGroups(String handle, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMGroupSearchConfig configObj = new ZIMGroupSearchConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getInt("nextFlag") : 0;
            configObj.isAlsoMatchGroupMemberUserName =
                config.hasKey("isAlsoMatchGroupMemberUserName")
                    ? config.getBoolean("isAlsoMatchGroupMemberUserName")
                    : false;
            configObj.isAlsoMatchGroupMemberNickname =
                config.hasKey("isAlsoMatchGroupMemberNickname")
                    ? config.getBoolean("isAlsoMatchGroupMemberNickname")
                    : false;
            if (config.hasKey("keywords")) {
                ArrayList<String> keywords = new ArrayList<>();
                for (Object key : config.getArray("keywords").toArrayList()) {
                    keywords.add((String) key);
                }
                configObj.keywords = keywords;
            }
        }

        zim.searchLocalGroups(
            configObj,
            new ZIMGroupsSearchedCallback() {
                @Override
                public void onGroupsSearched(
                    ArrayList<ZIMGroupSearchInfo> groupSearchInfoList,
                    int nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putInt("nextFlag", nextFlag);

                        WritableArray infoArray = Arguments.createArray();
                        for (ZIMGroupSearchInfo info : groupSearchInfoList) {
                            WritableMap infoMap = Arguments.createMap();

                            WritableMap baseInfoMap = Arguments.createMap();
                            baseInfoMap.putString("groupID", info.groupInfo.groupID);
                            baseInfoMap.putString("groupName", info.groupInfo.groupName);
                            baseInfoMap.putString("groupAvatarUrl", info.groupInfo.groupAvatarUrl);
                            infoMap.putMap("groupInfo", baseInfoMap);

                            infoMap.putArray(
                                "userList",
                                RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(info.userList)
                            );
                            infoArray.pushMap(infoMap);
                        }
                        returnMap.putArray("groupSearchInfoList", infoArray);

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }

    @ReactMethod
    public void searchGroupMembers(String handle, String groupID, ReadableMap config, final Promise promise) {
        ZIM zim = this.engineMap.get(handle);
        if (zim == null) {
            promise.reject("-1", "no instance");
            return;
        }

        ZIMGroupMemberSearchConfig configObj = new ZIMGroupMemberSearchConfig();
        if (config != null) {
            configObj.count = config.hasKey("count") ? config.getInt("count") : 0;
            configObj.nextFlag = config.hasKey("nextFlag") ? config.getInt("nextFlag") : 0;
            configObj.isAlsoMatchGroupMemberNickname =
                config.hasKey("isAlsoMatchGroupMemberNickname")
                    ? config.getBoolean("isAlsoMatchGroupMemberNickname")
                    : false;
            if (config.hasKey("keywords")) {
                ArrayList<String> keywords = new ArrayList<>();
                for (Object key : config.getArray("keywords").toArrayList()) {
                    keywords.add((String) key);
                }
                configObj.keywords = keywords;
            }
        }

        zim.searchLocalGroupMembers(
            groupID,
            configObj,
            new ZIMGroupMembersSearchedCallback() {
                @Override
                public void onGroupMembersSearched(
                    String groupID,
                    ArrayList<ZIMGroupMemberInfo> userList,
                    int nextFlag,
                    ZIMError errorInfo
                ) {
                    if (errorInfo.code == ZIMErrorCode.SUCCESS) {
                        WritableMap returnMap = Arguments.createMap();
                        returnMap.putString("groupID", groupID);
                        returnMap.putInt("nextFlag", nextFlag);
                        returnMap.putArray("userList", RNZIMConverter.convertGroupMemberInfoListFromJavaToJs(userList));

                        promise.resolve(returnMap);
                    } else {
                        promise.reject(String.valueOf(errorInfo.code.value()), errorInfo.message);
                    }
                }
            }
        );
    }
}
